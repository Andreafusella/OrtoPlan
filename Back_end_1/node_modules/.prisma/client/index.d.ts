
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Utente
 * 
 */
export type Utente = $Result.DefaultSelection<Prisma.$UtentePayload>
/**
 * Model Credenziali
 * 
 */
export type Credenziali = $Result.DefaultSelection<Prisma.$CredenzialiPayload>
/**
 * Model Piantagione
 * 
 */
export type Piantagione = $Result.DefaultSelection<Prisma.$PiantagionePayload>
/**
 * Model Pianta
 * 
 */
export type Pianta = $Result.DefaultSelection<Prisma.$PiantaPayload>
/**
 * Model Notifiche
 * 
 */
export type Notifiche = $Result.DefaultSelection<Prisma.$NotifichePayload>
/**
 * Model Annaffiature
 * 
 */
export type Annaffiature = $Result.DefaultSelection<Prisma.$AnnaffiaturePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Utentes
 * const utentes = await prisma.utente.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Utentes
   * const utentes = await prisma.utente.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.utente`: Exposes CRUD operations for the **Utente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Utentes
    * const utentes = await prisma.utente.findMany()
    * ```
    */
  get utente(): Prisma.UtenteDelegate<ExtArgs>;

  /**
   * `prisma.credenziali`: Exposes CRUD operations for the **Credenziali** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credenzialis
    * const credenzialis = await prisma.credenziali.findMany()
    * ```
    */
  get credenziali(): Prisma.CredenzialiDelegate<ExtArgs>;

  /**
   * `prisma.piantagione`: Exposes CRUD operations for the **Piantagione** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Piantagiones
    * const piantagiones = await prisma.piantagione.findMany()
    * ```
    */
  get piantagione(): Prisma.PiantagioneDelegate<ExtArgs>;

  /**
   * `prisma.pianta`: Exposes CRUD operations for the **Pianta** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Piantas
    * const piantas = await prisma.pianta.findMany()
    * ```
    */
  get pianta(): Prisma.PiantaDelegate<ExtArgs>;

  /**
   * `prisma.notifiche`: Exposes CRUD operations for the **Notifiche** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifiches
    * const notifiches = await prisma.notifiche.findMany()
    * ```
    */
  get notifiche(): Prisma.NotificheDelegate<ExtArgs>;

  /**
   * `prisma.annaffiature`: Exposes CRUD operations for the **Annaffiature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Annaffiatures
    * const annaffiatures = await prisma.annaffiature.findMany()
    * ```
    */
  get annaffiature(): Prisma.AnnaffiatureDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.14.0
   * Query Engine version: e9771e62de70f79a5e1c604a2d7c8e2a0a874b48
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Utente: 'Utente',
    Credenziali: 'Credenziali',
    Piantagione: 'Piantagione',
    Pianta: 'Pianta',
    Notifiche: 'Notifiche',
    Annaffiature: 'Annaffiature'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'utente' | 'credenziali' | 'piantagione' | 'pianta' | 'notifiche' | 'annaffiature'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Utente: {
        payload: Prisma.$UtentePayload<ExtArgs>
        fields: Prisma.UtenteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UtenteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtentePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UtenteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtentePayload>
          }
          findFirst: {
            args: Prisma.UtenteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtentePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UtenteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtentePayload>
          }
          findMany: {
            args: Prisma.UtenteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtentePayload>[]
          }
          create: {
            args: Prisma.UtenteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtentePayload>
          }
          createMany: {
            args: Prisma.UtenteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UtenteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtentePayload>
          }
          update: {
            args: Prisma.UtenteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtentePayload>
          }
          deleteMany: {
            args: Prisma.UtenteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UtenteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UtenteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UtentePayload>
          }
          aggregate: {
            args: Prisma.UtenteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUtente>
          }
          groupBy: {
            args: Prisma.UtenteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UtenteGroupByOutputType>[]
          }
          count: {
            args: Prisma.UtenteCountArgs<ExtArgs>,
            result: $Utils.Optional<UtenteCountAggregateOutputType> | number
          }
        }
      }
      Credenziali: {
        payload: Prisma.$CredenzialiPayload<ExtArgs>
        fields: Prisma.CredenzialiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CredenzialiFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CredenzialiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CredenzialiFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CredenzialiPayload>
          }
          findFirst: {
            args: Prisma.CredenzialiFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CredenzialiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CredenzialiFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CredenzialiPayload>
          }
          findMany: {
            args: Prisma.CredenzialiFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CredenzialiPayload>[]
          }
          create: {
            args: Prisma.CredenzialiCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CredenzialiPayload>
          }
          createMany: {
            args: Prisma.CredenzialiCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CredenzialiDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CredenzialiPayload>
          }
          update: {
            args: Prisma.CredenzialiUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CredenzialiPayload>
          }
          deleteMany: {
            args: Prisma.CredenzialiDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CredenzialiUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CredenzialiUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CredenzialiPayload>
          }
          aggregate: {
            args: Prisma.CredenzialiAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCredenziali>
          }
          groupBy: {
            args: Prisma.CredenzialiGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CredenzialiGroupByOutputType>[]
          }
          count: {
            args: Prisma.CredenzialiCountArgs<ExtArgs>,
            result: $Utils.Optional<CredenzialiCountAggregateOutputType> | number
          }
        }
      }
      Piantagione: {
        payload: Prisma.$PiantagionePayload<ExtArgs>
        fields: Prisma.PiantagioneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PiantagioneFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PiantagionePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PiantagioneFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PiantagionePayload>
          }
          findFirst: {
            args: Prisma.PiantagioneFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PiantagionePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PiantagioneFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PiantagionePayload>
          }
          findMany: {
            args: Prisma.PiantagioneFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PiantagionePayload>[]
          }
          create: {
            args: Prisma.PiantagioneCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PiantagionePayload>
          }
          createMany: {
            args: Prisma.PiantagioneCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PiantagioneDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PiantagionePayload>
          }
          update: {
            args: Prisma.PiantagioneUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PiantagionePayload>
          }
          deleteMany: {
            args: Prisma.PiantagioneDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PiantagioneUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PiantagioneUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PiantagionePayload>
          }
          aggregate: {
            args: Prisma.PiantagioneAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePiantagione>
          }
          groupBy: {
            args: Prisma.PiantagioneGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PiantagioneGroupByOutputType>[]
          }
          count: {
            args: Prisma.PiantagioneCountArgs<ExtArgs>,
            result: $Utils.Optional<PiantagioneCountAggregateOutputType> | number
          }
        }
      }
      Pianta: {
        payload: Prisma.$PiantaPayload<ExtArgs>
        fields: Prisma.PiantaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PiantaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PiantaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PiantaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PiantaPayload>
          }
          findFirst: {
            args: Prisma.PiantaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PiantaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PiantaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PiantaPayload>
          }
          findMany: {
            args: Prisma.PiantaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PiantaPayload>[]
          }
          create: {
            args: Prisma.PiantaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PiantaPayload>
          }
          createMany: {
            args: Prisma.PiantaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PiantaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PiantaPayload>
          }
          update: {
            args: Prisma.PiantaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PiantaPayload>
          }
          deleteMany: {
            args: Prisma.PiantaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PiantaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PiantaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PiantaPayload>
          }
          aggregate: {
            args: Prisma.PiantaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePianta>
          }
          groupBy: {
            args: Prisma.PiantaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PiantaGroupByOutputType>[]
          }
          count: {
            args: Prisma.PiantaCountArgs<ExtArgs>,
            result: $Utils.Optional<PiantaCountAggregateOutputType> | number
          }
        }
      }
      Notifiche: {
        payload: Prisma.$NotifichePayload<ExtArgs>
        fields: Prisma.NotificheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificheFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotifichePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificheFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotifichePayload>
          }
          findFirst: {
            args: Prisma.NotificheFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotifichePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificheFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotifichePayload>
          }
          findMany: {
            args: Prisma.NotificheFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotifichePayload>[]
          }
          create: {
            args: Prisma.NotificheCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotifichePayload>
          }
          createMany: {
            args: Prisma.NotificheCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NotificheDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotifichePayload>
          }
          update: {
            args: Prisma.NotificheUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotifichePayload>
          }
          deleteMany: {
            args: Prisma.NotificheDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NotificheUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NotificheUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotifichePayload>
          }
          aggregate: {
            args: Prisma.NotificheAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNotifiche>
          }
          groupBy: {
            args: Prisma.NotificheGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NotificheGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificheCountArgs<ExtArgs>,
            result: $Utils.Optional<NotificheCountAggregateOutputType> | number
          }
        }
      }
      Annaffiature: {
        payload: Prisma.$AnnaffiaturePayload<ExtArgs>
        fields: Prisma.AnnaffiatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnaffiatureFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnaffiaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnaffiatureFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnaffiaturePayload>
          }
          findFirst: {
            args: Prisma.AnnaffiatureFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnaffiaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnaffiatureFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnaffiaturePayload>
          }
          findMany: {
            args: Prisma.AnnaffiatureFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnaffiaturePayload>[]
          }
          create: {
            args: Prisma.AnnaffiatureCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnaffiaturePayload>
          }
          createMany: {
            args: Prisma.AnnaffiatureCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AnnaffiatureDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnaffiaturePayload>
          }
          update: {
            args: Prisma.AnnaffiatureUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnaffiaturePayload>
          }
          deleteMany: {
            args: Prisma.AnnaffiatureDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AnnaffiatureUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AnnaffiatureUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnnaffiaturePayload>
          }
          aggregate: {
            args: Prisma.AnnaffiatureAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAnnaffiature>
          }
          groupBy: {
            args: Prisma.AnnaffiatureGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AnnaffiatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnaffiatureCountArgs<ExtArgs>,
            result: $Utils.Optional<AnnaffiatureCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UtenteCountOutputType
   */

  export type UtenteCountOutputType = {
    piantagioni: number
    notifiche: number
    annaffiature: number
  }

  export type UtenteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    piantagioni?: boolean | UtenteCountOutputTypeCountPiantagioniArgs
    notifiche?: boolean | UtenteCountOutputTypeCountNotificheArgs
    annaffiature?: boolean | UtenteCountOutputTypeCountAnnaffiatureArgs
  }

  // Custom InputTypes
  /**
   * UtenteCountOutputType without action
   */
  export type UtenteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtenteCountOutputType
     */
    select?: UtenteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UtenteCountOutputType without action
   */
  export type UtenteCountOutputTypeCountPiantagioniArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PiantagioneWhereInput
  }

  /**
   * UtenteCountOutputType without action
   */
  export type UtenteCountOutputTypeCountNotificheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificheWhereInput
  }

  /**
   * UtenteCountOutputType without action
   */
  export type UtenteCountOutputTypeCountAnnaffiatureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnaffiatureWhereInput
  }


  /**
   * Count Type PiantagioneCountOutputType
   */

  export type PiantagioneCountOutputType = {
    notifiche: number
    annaffiature: number
  }

  export type PiantagioneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifiche?: boolean | PiantagioneCountOutputTypeCountNotificheArgs
    annaffiature?: boolean | PiantagioneCountOutputTypeCountAnnaffiatureArgs
  }

  // Custom InputTypes
  /**
   * PiantagioneCountOutputType without action
   */
  export type PiantagioneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PiantagioneCountOutputType
     */
    select?: PiantagioneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PiantagioneCountOutputType without action
   */
  export type PiantagioneCountOutputTypeCountNotificheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificheWhereInput
  }

  /**
   * PiantagioneCountOutputType without action
   */
  export type PiantagioneCountOutputTypeCountAnnaffiatureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnaffiatureWhereInput
  }


  /**
   * Count Type PiantaCountOutputType
   */

  export type PiantaCountOutputType = {
    piantagioni: number
  }

  export type PiantaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    piantagioni?: boolean | PiantaCountOutputTypeCountPiantagioniArgs
  }

  // Custom InputTypes
  /**
   * PiantaCountOutputType without action
   */
  export type PiantaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PiantaCountOutputType
     */
    select?: PiantaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PiantaCountOutputType without action
   */
  export type PiantaCountOutputTypeCountPiantagioniArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PiantagioneWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Utente
   */

  export type AggregateUtente = {
    _count: UtenteCountAggregateOutputType | null
    _avg: UtenteAvgAggregateOutputType | null
    _sum: UtenteSumAggregateOutputType | null
    _min: UtenteMinAggregateOutputType | null
    _max: UtenteMaxAggregateOutputType | null
  }

  export type UtenteAvgAggregateOutputType = {
    id_utente: number | null
  }

  export type UtenteSumAggregateOutputType = {
    id_utente: number | null
  }

  export type UtenteMinAggregateOutputType = {
    id_utente: number | null
    nome: string | null
    cognome: string | null
  }

  export type UtenteMaxAggregateOutputType = {
    id_utente: number | null
    nome: string | null
    cognome: string | null
  }

  export type UtenteCountAggregateOutputType = {
    id_utente: number
    nome: number
    cognome: number
    _all: number
  }


  export type UtenteAvgAggregateInputType = {
    id_utente?: true
  }

  export type UtenteSumAggregateInputType = {
    id_utente?: true
  }

  export type UtenteMinAggregateInputType = {
    id_utente?: true
    nome?: true
    cognome?: true
  }

  export type UtenteMaxAggregateInputType = {
    id_utente?: true
    nome?: true
    cognome?: true
  }

  export type UtenteCountAggregateInputType = {
    id_utente?: true
    nome?: true
    cognome?: true
    _all?: true
  }

  export type UtenteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Utente to aggregate.
     */
    where?: UtenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utentes to fetch.
     */
    orderBy?: UtenteOrderByWithRelationInput | UtenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UtenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Utentes
    **/
    _count?: true | UtenteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UtenteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UtenteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UtenteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UtenteMaxAggregateInputType
  }

  export type GetUtenteAggregateType<T extends UtenteAggregateArgs> = {
        [P in keyof T & keyof AggregateUtente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUtente[P]>
      : GetScalarType<T[P], AggregateUtente[P]>
  }




  export type UtenteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UtenteWhereInput
    orderBy?: UtenteOrderByWithAggregationInput | UtenteOrderByWithAggregationInput[]
    by: UtenteScalarFieldEnum[] | UtenteScalarFieldEnum
    having?: UtenteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UtenteCountAggregateInputType | true
    _avg?: UtenteAvgAggregateInputType
    _sum?: UtenteSumAggregateInputType
    _min?: UtenteMinAggregateInputType
    _max?: UtenteMaxAggregateInputType
  }

  export type UtenteGroupByOutputType = {
    id_utente: number
    nome: string
    cognome: string
    _count: UtenteCountAggregateOutputType | null
    _avg: UtenteAvgAggregateOutputType | null
    _sum: UtenteSumAggregateOutputType | null
    _min: UtenteMinAggregateOutputType | null
    _max: UtenteMaxAggregateOutputType | null
  }

  type GetUtenteGroupByPayload<T extends UtenteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UtenteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UtenteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UtenteGroupByOutputType[P]>
            : GetScalarType<T[P], UtenteGroupByOutputType[P]>
        }
      >
    >


  export type UtenteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_utente?: boolean
    nome?: boolean
    cognome?: boolean
    credenziali?: boolean | Utente$credenzialiArgs<ExtArgs>
    piantagioni?: boolean | Utente$piantagioniArgs<ExtArgs>
    notifiche?: boolean | Utente$notificheArgs<ExtArgs>
    annaffiature?: boolean | Utente$annaffiatureArgs<ExtArgs>
    _count?: boolean | UtenteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["utente"]>

  export type UtenteSelectScalar = {
    id_utente?: boolean
    nome?: boolean
    cognome?: boolean
  }


  export type UtenteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credenziali?: boolean | Utente$credenzialiArgs<ExtArgs>
    piantagioni?: boolean | Utente$piantagioniArgs<ExtArgs>
    notifiche?: boolean | Utente$notificheArgs<ExtArgs>
    annaffiature?: boolean | Utente$annaffiatureArgs<ExtArgs>
    _count?: boolean | UtenteCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UtentePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Utente"
    objects: {
      credenziali: Prisma.$CredenzialiPayload<ExtArgs> | null
      piantagioni: Prisma.$PiantagionePayload<ExtArgs>[]
      notifiche: Prisma.$NotifichePayload<ExtArgs>[]
      annaffiature: Prisma.$AnnaffiaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_utente: number
      nome: string
      cognome: string
    }, ExtArgs["result"]["utente"]>
    composites: {}
  }


  type UtenteGetPayload<S extends boolean | null | undefined | UtenteDefaultArgs> = $Result.GetResult<Prisma.$UtentePayload, S>

  type UtenteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UtenteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UtenteCountAggregateInputType | true
    }

  export interface UtenteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Utente'], meta: { name: 'Utente' } }
    /**
     * Find zero or one Utente that matches the filter.
     * @param {UtenteFindUniqueArgs} args - Arguments to find a Utente
     * @example
     * // Get one Utente
     * const utente = await prisma.utente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UtenteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UtenteFindUniqueArgs<ExtArgs>>
    ): Prisma__UtenteClient<$Result.GetResult<Prisma.$UtentePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Utente that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UtenteFindUniqueOrThrowArgs} args - Arguments to find a Utente
     * @example
     * // Get one Utente
     * const utente = await prisma.utente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UtenteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UtenteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UtenteClient<$Result.GetResult<Prisma.$UtentePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Utente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtenteFindFirstArgs} args - Arguments to find a Utente
     * @example
     * // Get one Utente
     * const utente = await prisma.utente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UtenteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UtenteFindFirstArgs<ExtArgs>>
    ): Prisma__UtenteClient<$Result.GetResult<Prisma.$UtentePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Utente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtenteFindFirstOrThrowArgs} args - Arguments to find a Utente
     * @example
     * // Get one Utente
     * const utente = await prisma.utente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UtenteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UtenteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UtenteClient<$Result.GetResult<Prisma.$UtentePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Utentes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtenteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Utentes
     * const utentes = await prisma.utente.findMany()
     * 
     * // Get first 10 Utentes
     * const utentes = await prisma.utente.findMany({ take: 10 })
     * 
     * // Only select the `id_utente`
     * const utenteWithId_utenteOnly = await prisma.utente.findMany({ select: { id_utente: true } })
     * 
    **/
    findMany<T extends UtenteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UtenteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtentePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Utente.
     * @param {UtenteCreateArgs} args - Arguments to create a Utente.
     * @example
     * // Create one Utente
     * const Utente = await prisma.utente.create({
     *   data: {
     *     // ... data to create a Utente
     *   }
     * })
     * 
    **/
    create<T extends UtenteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UtenteCreateArgs<ExtArgs>>
    ): Prisma__UtenteClient<$Result.GetResult<Prisma.$UtentePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Utentes.
     * @param {UtenteCreateManyArgs} args - Arguments to create many Utentes.
     * @example
     * // Create many Utentes
     * const utente = await prisma.utente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends UtenteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UtenteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Utente.
     * @param {UtenteDeleteArgs} args - Arguments to delete one Utente.
     * @example
     * // Delete one Utente
     * const Utente = await prisma.utente.delete({
     *   where: {
     *     // ... filter to delete one Utente
     *   }
     * })
     * 
    **/
    delete<T extends UtenteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UtenteDeleteArgs<ExtArgs>>
    ): Prisma__UtenteClient<$Result.GetResult<Prisma.$UtentePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Utente.
     * @param {UtenteUpdateArgs} args - Arguments to update one Utente.
     * @example
     * // Update one Utente
     * const utente = await prisma.utente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UtenteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UtenteUpdateArgs<ExtArgs>>
    ): Prisma__UtenteClient<$Result.GetResult<Prisma.$UtentePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Utentes.
     * @param {UtenteDeleteManyArgs} args - Arguments to filter Utentes to delete.
     * @example
     * // Delete a few Utentes
     * const { count } = await prisma.utente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UtenteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UtenteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Utentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtenteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Utentes
     * const utente = await prisma.utente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UtenteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UtenteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Utente.
     * @param {UtenteUpsertArgs} args - Arguments to update or create a Utente.
     * @example
     * // Update or create a Utente
     * const utente = await prisma.utente.upsert({
     *   create: {
     *     // ... data to create a Utente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Utente we want to update
     *   }
     * })
    **/
    upsert<T extends UtenteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UtenteUpsertArgs<ExtArgs>>
    ): Prisma__UtenteClient<$Result.GetResult<Prisma.$UtentePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Utentes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtenteCountArgs} args - Arguments to filter Utentes to count.
     * @example
     * // Count the number of Utentes
     * const count = await prisma.utente.count({
     *   where: {
     *     // ... the filter for the Utentes we want to count
     *   }
     * })
    **/
    count<T extends UtenteCountArgs>(
      args?: Subset<T, UtenteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UtenteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Utente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtenteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UtenteAggregateArgs>(args: Subset<T, UtenteAggregateArgs>): Prisma.PrismaPromise<GetUtenteAggregateType<T>>

    /**
     * Group by Utente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtenteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UtenteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UtenteGroupByArgs['orderBy'] }
        : { orderBy?: UtenteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UtenteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUtenteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Utente model
   */
  readonly fields: UtenteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Utente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UtenteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    credenziali<T extends Utente$credenzialiArgs<ExtArgs> = {}>(args?: Subset<T, Utente$credenzialiArgs<ExtArgs>>): Prisma__CredenzialiClient<$Result.GetResult<Prisma.$CredenzialiPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    piantagioni<T extends Utente$piantagioniArgs<ExtArgs> = {}>(args?: Subset<T, Utente$piantagioniArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PiantagionePayload<ExtArgs>, T, 'findMany'> | Null>;

    notifiche<T extends Utente$notificheArgs<ExtArgs> = {}>(args?: Subset<T, Utente$notificheArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotifichePayload<ExtArgs>, T, 'findMany'> | Null>;

    annaffiature<T extends Utente$annaffiatureArgs<ExtArgs> = {}>(args?: Subset<T, Utente$annaffiatureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnaffiaturePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Utente model
   */ 
  interface UtenteFieldRefs {
    readonly id_utente: FieldRef<"Utente", 'Int'>
    readonly nome: FieldRef<"Utente", 'String'>
    readonly cognome: FieldRef<"Utente", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Utente findUnique
   */
  export type UtenteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utente
     */
    select?: UtenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtenteInclude<ExtArgs> | null
    /**
     * Filter, which Utente to fetch.
     */
    where: UtenteWhereUniqueInput
  }

  /**
   * Utente findUniqueOrThrow
   */
  export type UtenteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utente
     */
    select?: UtenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtenteInclude<ExtArgs> | null
    /**
     * Filter, which Utente to fetch.
     */
    where: UtenteWhereUniqueInput
  }

  /**
   * Utente findFirst
   */
  export type UtenteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utente
     */
    select?: UtenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtenteInclude<ExtArgs> | null
    /**
     * Filter, which Utente to fetch.
     */
    where?: UtenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utentes to fetch.
     */
    orderBy?: UtenteOrderByWithRelationInput | UtenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Utentes.
     */
    cursor?: UtenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Utentes.
     */
    distinct?: UtenteScalarFieldEnum | UtenteScalarFieldEnum[]
  }

  /**
   * Utente findFirstOrThrow
   */
  export type UtenteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utente
     */
    select?: UtenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtenteInclude<ExtArgs> | null
    /**
     * Filter, which Utente to fetch.
     */
    where?: UtenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utentes to fetch.
     */
    orderBy?: UtenteOrderByWithRelationInput | UtenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Utentes.
     */
    cursor?: UtenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utentes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Utentes.
     */
    distinct?: UtenteScalarFieldEnum | UtenteScalarFieldEnum[]
  }

  /**
   * Utente findMany
   */
  export type UtenteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utente
     */
    select?: UtenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtenteInclude<ExtArgs> | null
    /**
     * Filter, which Utentes to fetch.
     */
    where?: UtenteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utentes to fetch.
     */
    orderBy?: UtenteOrderByWithRelationInput | UtenteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Utentes.
     */
    cursor?: UtenteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utentes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utentes.
     */
    skip?: number
    distinct?: UtenteScalarFieldEnum | UtenteScalarFieldEnum[]
  }

  /**
   * Utente create
   */
  export type UtenteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utente
     */
    select?: UtenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtenteInclude<ExtArgs> | null
    /**
     * The data needed to create a Utente.
     */
    data: XOR<UtenteCreateInput, UtenteUncheckedCreateInput>
  }

  /**
   * Utente createMany
   */
  export type UtenteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Utentes.
     */
    data: UtenteCreateManyInput | UtenteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Utente update
   */
  export type UtenteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utente
     */
    select?: UtenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtenteInclude<ExtArgs> | null
    /**
     * The data needed to update a Utente.
     */
    data: XOR<UtenteUpdateInput, UtenteUncheckedUpdateInput>
    /**
     * Choose, which Utente to update.
     */
    where: UtenteWhereUniqueInput
  }

  /**
   * Utente updateMany
   */
  export type UtenteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Utentes.
     */
    data: XOR<UtenteUpdateManyMutationInput, UtenteUncheckedUpdateManyInput>
    /**
     * Filter which Utentes to update
     */
    where?: UtenteWhereInput
  }

  /**
   * Utente upsert
   */
  export type UtenteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utente
     */
    select?: UtenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtenteInclude<ExtArgs> | null
    /**
     * The filter to search for the Utente to update in case it exists.
     */
    where: UtenteWhereUniqueInput
    /**
     * In case the Utente found by the `where` argument doesn't exist, create a new Utente with this data.
     */
    create: XOR<UtenteCreateInput, UtenteUncheckedCreateInput>
    /**
     * In case the Utente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UtenteUpdateInput, UtenteUncheckedUpdateInput>
  }

  /**
   * Utente delete
   */
  export type UtenteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utente
     */
    select?: UtenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtenteInclude<ExtArgs> | null
    /**
     * Filter which Utente to delete.
     */
    where: UtenteWhereUniqueInput
  }

  /**
   * Utente deleteMany
   */
  export type UtenteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Utentes to delete
     */
    where?: UtenteWhereInput
  }

  /**
   * Utente.credenziali
   */
  export type Utente$credenzialiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credenziali
     */
    select?: CredenzialiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredenzialiInclude<ExtArgs> | null
    where?: CredenzialiWhereInput
  }

  /**
   * Utente.piantagioni
   */
  export type Utente$piantagioniArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piantagione
     */
    select?: PiantagioneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantagioneInclude<ExtArgs> | null
    where?: PiantagioneWhereInput
    orderBy?: PiantagioneOrderByWithRelationInput | PiantagioneOrderByWithRelationInput[]
    cursor?: PiantagioneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PiantagioneScalarFieldEnum | PiantagioneScalarFieldEnum[]
  }

  /**
   * Utente.notifiche
   */
  export type Utente$notificheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifiche
     */
    select?: NotificheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificheInclude<ExtArgs> | null
    where?: NotificheWhereInput
    orderBy?: NotificheOrderByWithRelationInput | NotificheOrderByWithRelationInput[]
    cursor?: NotificheWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificheScalarFieldEnum | NotificheScalarFieldEnum[]
  }

  /**
   * Utente.annaffiature
   */
  export type Utente$annaffiatureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annaffiature
     */
    select?: AnnaffiatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnaffiatureInclude<ExtArgs> | null
    where?: AnnaffiatureWhereInput
    orderBy?: AnnaffiatureOrderByWithRelationInput | AnnaffiatureOrderByWithRelationInput[]
    cursor?: AnnaffiatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnaffiatureScalarFieldEnum | AnnaffiatureScalarFieldEnum[]
  }

  /**
   * Utente without action
   */
  export type UtenteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utente
     */
    select?: UtenteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtenteInclude<ExtArgs> | null
  }


  /**
   * Model Credenziali
   */

  export type AggregateCredenziali = {
    _count: CredenzialiCountAggregateOutputType | null
    _avg: CredenzialiAvgAggregateOutputType | null
    _sum: CredenzialiSumAggregateOutputType | null
    _min: CredenzialiMinAggregateOutputType | null
    _max: CredenzialiMaxAggregateOutputType | null
  }

  export type CredenzialiAvgAggregateOutputType = {
    id_utente: number | null
  }

  export type CredenzialiSumAggregateOutputType = {
    id_utente: number | null
  }

  export type CredenzialiMinAggregateOutputType = {
    id_utente: number | null
    email: string | null
    password: string | null
  }

  export type CredenzialiMaxAggregateOutputType = {
    id_utente: number | null
    email: string | null
    password: string | null
  }

  export type CredenzialiCountAggregateOutputType = {
    id_utente: number
    email: number
    password: number
    _all: number
  }


  export type CredenzialiAvgAggregateInputType = {
    id_utente?: true
  }

  export type CredenzialiSumAggregateInputType = {
    id_utente?: true
  }

  export type CredenzialiMinAggregateInputType = {
    id_utente?: true
    email?: true
    password?: true
  }

  export type CredenzialiMaxAggregateInputType = {
    id_utente?: true
    email?: true
    password?: true
  }

  export type CredenzialiCountAggregateInputType = {
    id_utente?: true
    email?: true
    password?: true
    _all?: true
  }

  export type CredenzialiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Credenziali to aggregate.
     */
    where?: CredenzialiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credenzialis to fetch.
     */
    orderBy?: CredenzialiOrderByWithRelationInput | CredenzialiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CredenzialiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credenzialis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credenzialis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Credenzialis
    **/
    _count?: true | CredenzialiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CredenzialiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CredenzialiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CredenzialiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CredenzialiMaxAggregateInputType
  }

  export type GetCredenzialiAggregateType<T extends CredenzialiAggregateArgs> = {
        [P in keyof T & keyof AggregateCredenziali]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredenziali[P]>
      : GetScalarType<T[P], AggregateCredenziali[P]>
  }




  export type CredenzialiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CredenzialiWhereInput
    orderBy?: CredenzialiOrderByWithAggregationInput | CredenzialiOrderByWithAggregationInput[]
    by: CredenzialiScalarFieldEnum[] | CredenzialiScalarFieldEnum
    having?: CredenzialiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CredenzialiCountAggregateInputType | true
    _avg?: CredenzialiAvgAggregateInputType
    _sum?: CredenzialiSumAggregateInputType
    _min?: CredenzialiMinAggregateInputType
    _max?: CredenzialiMaxAggregateInputType
  }

  export type CredenzialiGroupByOutputType = {
    id_utente: number
    email: string
    password: string
    _count: CredenzialiCountAggregateOutputType | null
    _avg: CredenzialiAvgAggregateOutputType | null
    _sum: CredenzialiSumAggregateOutputType | null
    _min: CredenzialiMinAggregateOutputType | null
    _max: CredenzialiMaxAggregateOutputType | null
  }

  type GetCredenzialiGroupByPayload<T extends CredenzialiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CredenzialiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CredenzialiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CredenzialiGroupByOutputType[P]>
            : GetScalarType<T[P], CredenzialiGroupByOutputType[P]>
        }
      >
    >


  export type CredenzialiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_utente?: boolean
    email?: boolean
    password?: boolean
    utente?: boolean | UtenteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credenziali"]>

  export type CredenzialiSelectScalar = {
    id_utente?: boolean
    email?: boolean
    password?: boolean
  }


  export type CredenzialiInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utente?: boolean | UtenteDefaultArgs<ExtArgs>
  }


  export type $CredenzialiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Credenziali"
    objects: {
      utente: Prisma.$UtentePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_utente: number
      email: string
      password: string
    }, ExtArgs["result"]["credenziali"]>
    composites: {}
  }


  type CredenzialiGetPayload<S extends boolean | null | undefined | CredenzialiDefaultArgs> = $Result.GetResult<Prisma.$CredenzialiPayload, S>

  type CredenzialiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CredenzialiFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CredenzialiCountAggregateInputType | true
    }

  export interface CredenzialiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Credenziali'], meta: { name: 'Credenziali' } }
    /**
     * Find zero or one Credenziali that matches the filter.
     * @param {CredenzialiFindUniqueArgs} args - Arguments to find a Credenziali
     * @example
     * // Get one Credenziali
     * const credenziali = await prisma.credenziali.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CredenzialiFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CredenzialiFindUniqueArgs<ExtArgs>>
    ): Prisma__CredenzialiClient<$Result.GetResult<Prisma.$CredenzialiPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Credenziali that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CredenzialiFindUniqueOrThrowArgs} args - Arguments to find a Credenziali
     * @example
     * // Get one Credenziali
     * const credenziali = await prisma.credenziali.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CredenzialiFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CredenzialiFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CredenzialiClient<$Result.GetResult<Prisma.$CredenzialiPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Credenziali that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredenzialiFindFirstArgs} args - Arguments to find a Credenziali
     * @example
     * // Get one Credenziali
     * const credenziali = await prisma.credenziali.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CredenzialiFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CredenzialiFindFirstArgs<ExtArgs>>
    ): Prisma__CredenzialiClient<$Result.GetResult<Prisma.$CredenzialiPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Credenziali that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredenzialiFindFirstOrThrowArgs} args - Arguments to find a Credenziali
     * @example
     * // Get one Credenziali
     * const credenziali = await prisma.credenziali.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CredenzialiFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CredenzialiFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CredenzialiClient<$Result.GetResult<Prisma.$CredenzialiPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Credenzialis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredenzialiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credenzialis
     * const credenzialis = await prisma.credenziali.findMany()
     * 
     * // Get first 10 Credenzialis
     * const credenzialis = await prisma.credenziali.findMany({ take: 10 })
     * 
     * // Only select the `id_utente`
     * const credenzialiWithId_utenteOnly = await prisma.credenziali.findMany({ select: { id_utente: true } })
     * 
    **/
    findMany<T extends CredenzialiFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CredenzialiFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredenzialiPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Credenziali.
     * @param {CredenzialiCreateArgs} args - Arguments to create a Credenziali.
     * @example
     * // Create one Credenziali
     * const Credenziali = await prisma.credenziali.create({
     *   data: {
     *     // ... data to create a Credenziali
     *   }
     * })
     * 
    **/
    create<T extends CredenzialiCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CredenzialiCreateArgs<ExtArgs>>
    ): Prisma__CredenzialiClient<$Result.GetResult<Prisma.$CredenzialiPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Credenzialis.
     * @param {CredenzialiCreateManyArgs} args - Arguments to create many Credenzialis.
     * @example
     * // Create many Credenzialis
     * const credenziali = await prisma.credenziali.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends CredenzialiCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CredenzialiCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Credenziali.
     * @param {CredenzialiDeleteArgs} args - Arguments to delete one Credenziali.
     * @example
     * // Delete one Credenziali
     * const Credenziali = await prisma.credenziali.delete({
     *   where: {
     *     // ... filter to delete one Credenziali
     *   }
     * })
     * 
    **/
    delete<T extends CredenzialiDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CredenzialiDeleteArgs<ExtArgs>>
    ): Prisma__CredenzialiClient<$Result.GetResult<Prisma.$CredenzialiPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Credenziali.
     * @param {CredenzialiUpdateArgs} args - Arguments to update one Credenziali.
     * @example
     * // Update one Credenziali
     * const credenziali = await prisma.credenziali.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CredenzialiUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CredenzialiUpdateArgs<ExtArgs>>
    ): Prisma__CredenzialiClient<$Result.GetResult<Prisma.$CredenzialiPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Credenzialis.
     * @param {CredenzialiDeleteManyArgs} args - Arguments to filter Credenzialis to delete.
     * @example
     * // Delete a few Credenzialis
     * const { count } = await prisma.credenziali.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CredenzialiDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CredenzialiDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credenzialis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredenzialiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credenzialis
     * const credenziali = await prisma.credenziali.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CredenzialiUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CredenzialiUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Credenziali.
     * @param {CredenzialiUpsertArgs} args - Arguments to update or create a Credenziali.
     * @example
     * // Update or create a Credenziali
     * const credenziali = await prisma.credenziali.upsert({
     *   create: {
     *     // ... data to create a Credenziali
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credenziali we want to update
     *   }
     * })
    **/
    upsert<T extends CredenzialiUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CredenzialiUpsertArgs<ExtArgs>>
    ): Prisma__CredenzialiClient<$Result.GetResult<Prisma.$CredenzialiPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Credenzialis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredenzialiCountArgs} args - Arguments to filter Credenzialis to count.
     * @example
     * // Count the number of Credenzialis
     * const count = await prisma.credenziali.count({
     *   where: {
     *     // ... the filter for the Credenzialis we want to count
     *   }
     * })
    **/
    count<T extends CredenzialiCountArgs>(
      args?: Subset<T, CredenzialiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CredenzialiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credenziali.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredenzialiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CredenzialiAggregateArgs>(args: Subset<T, CredenzialiAggregateArgs>): Prisma.PrismaPromise<GetCredenzialiAggregateType<T>>

    /**
     * Group by Credenziali.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredenzialiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CredenzialiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CredenzialiGroupByArgs['orderBy'] }
        : { orderBy?: CredenzialiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CredenzialiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCredenzialiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Credenziali model
   */
  readonly fields: CredenzialiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Credenziali.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CredenzialiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    utente<T extends UtenteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UtenteDefaultArgs<ExtArgs>>): Prisma__UtenteClient<$Result.GetResult<Prisma.$UtentePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Credenziali model
   */ 
  interface CredenzialiFieldRefs {
    readonly id_utente: FieldRef<"Credenziali", 'Int'>
    readonly email: FieldRef<"Credenziali", 'String'>
    readonly password: FieldRef<"Credenziali", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Credenziali findUnique
   */
  export type CredenzialiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credenziali
     */
    select?: CredenzialiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredenzialiInclude<ExtArgs> | null
    /**
     * Filter, which Credenziali to fetch.
     */
    where: CredenzialiWhereUniqueInput
  }

  /**
   * Credenziali findUniqueOrThrow
   */
  export type CredenzialiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credenziali
     */
    select?: CredenzialiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredenzialiInclude<ExtArgs> | null
    /**
     * Filter, which Credenziali to fetch.
     */
    where: CredenzialiWhereUniqueInput
  }

  /**
   * Credenziali findFirst
   */
  export type CredenzialiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credenziali
     */
    select?: CredenzialiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredenzialiInclude<ExtArgs> | null
    /**
     * Filter, which Credenziali to fetch.
     */
    where?: CredenzialiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credenzialis to fetch.
     */
    orderBy?: CredenzialiOrderByWithRelationInput | CredenzialiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Credenzialis.
     */
    cursor?: CredenzialiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credenzialis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credenzialis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Credenzialis.
     */
    distinct?: CredenzialiScalarFieldEnum | CredenzialiScalarFieldEnum[]
  }

  /**
   * Credenziali findFirstOrThrow
   */
  export type CredenzialiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credenziali
     */
    select?: CredenzialiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredenzialiInclude<ExtArgs> | null
    /**
     * Filter, which Credenziali to fetch.
     */
    where?: CredenzialiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credenzialis to fetch.
     */
    orderBy?: CredenzialiOrderByWithRelationInput | CredenzialiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Credenzialis.
     */
    cursor?: CredenzialiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credenzialis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credenzialis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Credenzialis.
     */
    distinct?: CredenzialiScalarFieldEnum | CredenzialiScalarFieldEnum[]
  }

  /**
   * Credenziali findMany
   */
  export type CredenzialiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credenziali
     */
    select?: CredenzialiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredenzialiInclude<ExtArgs> | null
    /**
     * Filter, which Credenzialis to fetch.
     */
    where?: CredenzialiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credenzialis to fetch.
     */
    orderBy?: CredenzialiOrderByWithRelationInput | CredenzialiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Credenzialis.
     */
    cursor?: CredenzialiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credenzialis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credenzialis.
     */
    skip?: number
    distinct?: CredenzialiScalarFieldEnum | CredenzialiScalarFieldEnum[]
  }

  /**
   * Credenziali create
   */
  export type CredenzialiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credenziali
     */
    select?: CredenzialiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredenzialiInclude<ExtArgs> | null
    /**
     * The data needed to create a Credenziali.
     */
    data: XOR<CredenzialiCreateInput, CredenzialiUncheckedCreateInput>
  }

  /**
   * Credenziali createMany
   */
  export type CredenzialiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Credenzialis.
     */
    data: CredenzialiCreateManyInput | CredenzialiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Credenziali update
   */
  export type CredenzialiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credenziali
     */
    select?: CredenzialiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredenzialiInclude<ExtArgs> | null
    /**
     * The data needed to update a Credenziali.
     */
    data: XOR<CredenzialiUpdateInput, CredenzialiUncheckedUpdateInput>
    /**
     * Choose, which Credenziali to update.
     */
    where: CredenzialiWhereUniqueInput
  }

  /**
   * Credenziali updateMany
   */
  export type CredenzialiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Credenzialis.
     */
    data: XOR<CredenzialiUpdateManyMutationInput, CredenzialiUncheckedUpdateManyInput>
    /**
     * Filter which Credenzialis to update
     */
    where?: CredenzialiWhereInput
  }

  /**
   * Credenziali upsert
   */
  export type CredenzialiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credenziali
     */
    select?: CredenzialiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredenzialiInclude<ExtArgs> | null
    /**
     * The filter to search for the Credenziali to update in case it exists.
     */
    where: CredenzialiWhereUniqueInput
    /**
     * In case the Credenziali found by the `where` argument doesn't exist, create a new Credenziali with this data.
     */
    create: XOR<CredenzialiCreateInput, CredenzialiUncheckedCreateInput>
    /**
     * In case the Credenziali was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CredenzialiUpdateInput, CredenzialiUncheckedUpdateInput>
  }

  /**
   * Credenziali delete
   */
  export type CredenzialiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credenziali
     */
    select?: CredenzialiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredenzialiInclude<ExtArgs> | null
    /**
     * Filter which Credenziali to delete.
     */
    where: CredenzialiWhereUniqueInput
  }

  /**
   * Credenziali deleteMany
   */
  export type CredenzialiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Credenzialis to delete
     */
    where?: CredenzialiWhereInput
  }

  /**
   * Credenziali without action
   */
  export type CredenzialiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credenziali
     */
    select?: CredenzialiSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredenzialiInclude<ExtArgs> | null
  }


  /**
   * Model Piantagione
   */

  export type AggregatePiantagione = {
    _count: PiantagioneCountAggregateOutputType | null
    _avg: PiantagioneAvgAggregateOutputType | null
    _sum: PiantagioneSumAggregateOutputType | null
    _min: PiantagioneMinAggregateOutputType | null
    _max: PiantagioneMaxAggregateOutputType | null
  }

  export type PiantagioneAvgAggregateOutputType = {
    id_piantagione: number | null
    id_utente: number | null
    n_slot: number | null
    id_pianta: number | null
  }

  export type PiantagioneSumAggregateOutputType = {
    id_piantagione: number | null
    id_utente: number | null
    n_slot: number | null
    id_pianta: number | null
  }

  export type PiantagioneMinAggregateOutputType = {
    id_piantagione: number | null
    id_utente: number | null
    nome: string | null
    n_slot: number | null
    data_inizio: Date | null
    id_pianta: number | null
  }

  export type PiantagioneMaxAggregateOutputType = {
    id_piantagione: number | null
    id_utente: number | null
    nome: string | null
    n_slot: number | null
    data_inizio: Date | null
    id_pianta: number | null
  }

  export type PiantagioneCountAggregateOutputType = {
    id_piantagione: number
    id_utente: number
    nome: number
    n_slot: number
    data_inizio: number
    id_pianta: number
    _all: number
  }


  export type PiantagioneAvgAggregateInputType = {
    id_piantagione?: true
    id_utente?: true
    n_slot?: true
    id_pianta?: true
  }

  export type PiantagioneSumAggregateInputType = {
    id_piantagione?: true
    id_utente?: true
    n_slot?: true
    id_pianta?: true
  }

  export type PiantagioneMinAggregateInputType = {
    id_piantagione?: true
    id_utente?: true
    nome?: true
    n_slot?: true
    data_inizio?: true
    id_pianta?: true
  }

  export type PiantagioneMaxAggregateInputType = {
    id_piantagione?: true
    id_utente?: true
    nome?: true
    n_slot?: true
    data_inizio?: true
    id_pianta?: true
  }

  export type PiantagioneCountAggregateInputType = {
    id_piantagione?: true
    id_utente?: true
    nome?: true
    n_slot?: true
    data_inizio?: true
    id_pianta?: true
    _all?: true
  }

  export type PiantagioneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Piantagione to aggregate.
     */
    where?: PiantagioneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Piantagiones to fetch.
     */
    orderBy?: PiantagioneOrderByWithRelationInput | PiantagioneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PiantagioneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Piantagiones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Piantagiones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Piantagiones
    **/
    _count?: true | PiantagioneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PiantagioneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PiantagioneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PiantagioneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PiantagioneMaxAggregateInputType
  }

  export type GetPiantagioneAggregateType<T extends PiantagioneAggregateArgs> = {
        [P in keyof T & keyof AggregatePiantagione]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePiantagione[P]>
      : GetScalarType<T[P], AggregatePiantagione[P]>
  }




  export type PiantagioneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PiantagioneWhereInput
    orderBy?: PiantagioneOrderByWithAggregationInput | PiantagioneOrderByWithAggregationInput[]
    by: PiantagioneScalarFieldEnum[] | PiantagioneScalarFieldEnum
    having?: PiantagioneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PiantagioneCountAggregateInputType | true
    _avg?: PiantagioneAvgAggregateInputType
    _sum?: PiantagioneSumAggregateInputType
    _min?: PiantagioneMinAggregateInputType
    _max?: PiantagioneMaxAggregateInputType
  }

  export type PiantagioneGroupByOutputType = {
    id_piantagione: number
    id_utente: number
    nome: string
    n_slot: number
    data_inizio: Date
    id_pianta: number
    _count: PiantagioneCountAggregateOutputType | null
    _avg: PiantagioneAvgAggregateOutputType | null
    _sum: PiantagioneSumAggregateOutputType | null
    _min: PiantagioneMinAggregateOutputType | null
    _max: PiantagioneMaxAggregateOutputType | null
  }

  type GetPiantagioneGroupByPayload<T extends PiantagioneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PiantagioneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PiantagioneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PiantagioneGroupByOutputType[P]>
            : GetScalarType<T[P], PiantagioneGroupByOutputType[P]>
        }
      >
    >


  export type PiantagioneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_piantagione?: boolean
    id_utente?: boolean
    nome?: boolean
    n_slot?: boolean
    data_inizio?: boolean
    id_pianta?: boolean
    utente?: boolean | UtenteDefaultArgs<ExtArgs>
    pianta?: boolean | PiantaDefaultArgs<ExtArgs>
    notifiche?: boolean | Piantagione$notificheArgs<ExtArgs>
    annaffiature?: boolean | Piantagione$annaffiatureArgs<ExtArgs>
    _count?: boolean | PiantagioneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["piantagione"]>

  export type PiantagioneSelectScalar = {
    id_piantagione?: boolean
    id_utente?: boolean
    nome?: boolean
    n_slot?: boolean
    data_inizio?: boolean
    id_pianta?: boolean
  }


  export type PiantagioneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utente?: boolean | UtenteDefaultArgs<ExtArgs>
    pianta?: boolean | PiantaDefaultArgs<ExtArgs>
    notifiche?: boolean | Piantagione$notificheArgs<ExtArgs>
    annaffiature?: boolean | Piantagione$annaffiatureArgs<ExtArgs>
    _count?: boolean | PiantagioneCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PiantagionePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Piantagione"
    objects: {
      utente: Prisma.$UtentePayload<ExtArgs>
      pianta: Prisma.$PiantaPayload<ExtArgs>
      notifiche: Prisma.$NotifichePayload<ExtArgs>[]
      annaffiature: Prisma.$AnnaffiaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_piantagione: number
      id_utente: number
      nome: string
      n_slot: number
      data_inizio: Date
      id_pianta: number
    }, ExtArgs["result"]["piantagione"]>
    composites: {}
  }


  type PiantagioneGetPayload<S extends boolean | null | undefined | PiantagioneDefaultArgs> = $Result.GetResult<Prisma.$PiantagionePayload, S>

  type PiantagioneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PiantagioneFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PiantagioneCountAggregateInputType | true
    }

  export interface PiantagioneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Piantagione'], meta: { name: 'Piantagione' } }
    /**
     * Find zero or one Piantagione that matches the filter.
     * @param {PiantagioneFindUniqueArgs} args - Arguments to find a Piantagione
     * @example
     * // Get one Piantagione
     * const piantagione = await prisma.piantagione.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PiantagioneFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PiantagioneFindUniqueArgs<ExtArgs>>
    ): Prisma__PiantagioneClient<$Result.GetResult<Prisma.$PiantagionePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Piantagione that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PiantagioneFindUniqueOrThrowArgs} args - Arguments to find a Piantagione
     * @example
     * // Get one Piantagione
     * const piantagione = await prisma.piantagione.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PiantagioneFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PiantagioneFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PiantagioneClient<$Result.GetResult<Prisma.$PiantagionePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Piantagione that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PiantagioneFindFirstArgs} args - Arguments to find a Piantagione
     * @example
     * // Get one Piantagione
     * const piantagione = await prisma.piantagione.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PiantagioneFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PiantagioneFindFirstArgs<ExtArgs>>
    ): Prisma__PiantagioneClient<$Result.GetResult<Prisma.$PiantagionePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Piantagione that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PiantagioneFindFirstOrThrowArgs} args - Arguments to find a Piantagione
     * @example
     * // Get one Piantagione
     * const piantagione = await prisma.piantagione.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PiantagioneFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PiantagioneFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PiantagioneClient<$Result.GetResult<Prisma.$PiantagionePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Piantagiones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PiantagioneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Piantagiones
     * const piantagiones = await prisma.piantagione.findMany()
     * 
     * // Get first 10 Piantagiones
     * const piantagiones = await prisma.piantagione.findMany({ take: 10 })
     * 
     * // Only select the `id_piantagione`
     * const piantagioneWithId_piantagioneOnly = await prisma.piantagione.findMany({ select: { id_piantagione: true } })
     * 
    **/
    findMany<T extends PiantagioneFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PiantagioneFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PiantagionePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Piantagione.
     * @param {PiantagioneCreateArgs} args - Arguments to create a Piantagione.
     * @example
     * // Create one Piantagione
     * const Piantagione = await prisma.piantagione.create({
     *   data: {
     *     // ... data to create a Piantagione
     *   }
     * })
     * 
    **/
    create<T extends PiantagioneCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PiantagioneCreateArgs<ExtArgs>>
    ): Prisma__PiantagioneClient<$Result.GetResult<Prisma.$PiantagionePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Piantagiones.
     * @param {PiantagioneCreateManyArgs} args - Arguments to create many Piantagiones.
     * @example
     * // Create many Piantagiones
     * const piantagione = await prisma.piantagione.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends PiantagioneCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PiantagioneCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Piantagione.
     * @param {PiantagioneDeleteArgs} args - Arguments to delete one Piantagione.
     * @example
     * // Delete one Piantagione
     * const Piantagione = await prisma.piantagione.delete({
     *   where: {
     *     // ... filter to delete one Piantagione
     *   }
     * })
     * 
    **/
    delete<T extends PiantagioneDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PiantagioneDeleteArgs<ExtArgs>>
    ): Prisma__PiantagioneClient<$Result.GetResult<Prisma.$PiantagionePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Piantagione.
     * @param {PiantagioneUpdateArgs} args - Arguments to update one Piantagione.
     * @example
     * // Update one Piantagione
     * const piantagione = await prisma.piantagione.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PiantagioneUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PiantagioneUpdateArgs<ExtArgs>>
    ): Prisma__PiantagioneClient<$Result.GetResult<Prisma.$PiantagionePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Piantagiones.
     * @param {PiantagioneDeleteManyArgs} args - Arguments to filter Piantagiones to delete.
     * @example
     * // Delete a few Piantagiones
     * const { count } = await prisma.piantagione.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PiantagioneDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PiantagioneDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Piantagiones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PiantagioneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Piantagiones
     * const piantagione = await prisma.piantagione.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PiantagioneUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PiantagioneUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Piantagione.
     * @param {PiantagioneUpsertArgs} args - Arguments to update or create a Piantagione.
     * @example
     * // Update or create a Piantagione
     * const piantagione = await prisma.piantagione.upsert({
     *   create: {
     *     // ... data to create a Piantagione
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Piantagione we want to update
     *   }
     * })
    **/
    upsert<T extends PiantagioneUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PiantagioneUpsertArgs<ExtArgs>>
    ): Prisma__PiantagioneClient<$Result.GetResult<Prisma.$PiantagionePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Piantagiones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PiantagioneCountArgs} args - Arguments to filter Piantagiones to count.
     * @example
     * // Count the number of Piantagiones
     * const count = await prisma.piantagione.count({
     *   where: {
     *     // ... the filter for the Piantagiones we want to count
     *   }
     * })
    **/
    count<T extends PiantagioneCountArgs>(
      args?: Subset<T, PiantagioneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PiantagioneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Piantagione.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PiantagioneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PiantagioneAggregateArgs>(args: Subset<T, PiantagioneAggregateArgs>): Prisma.PrismaPromise<GetPiantagioneAggregateType<T>>

    /**
     * Group by Piantagione.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PiantagioneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PiantagioneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PiantagioneGroupByArgs['orderBy'] }
        : { orderBy?: PiantagioneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PiantagioneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPiantagioneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Piantagione model
   */
  readonly fields: PiantagioneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Piantagione.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PiantagioneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    utente<T extends UtenteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UtenteDefaultArgs<ExtArgs>>): Prisma__UtenteClient<$Result.GetResult<Prisma.$UtentePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    pianta<T extends PiantaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PiantaDefaultArgs<ExtArgs>>): Prisma__PiantaClient<$Result.GetResult<Prisma.$PiantaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    notifiche<T extends Piantagione$notificheArgs<ExtArgs> = {}>(args?: Subset<T, Piantagione$notificheArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotifichePayload<ExtArgs>, T, 'findMany'> | Null>;

    annaffiature<T extends Piantagione$annaffiatureArgs<ExtArgs> = {}>(args?: Subset<T, Piantagione$annaffiatureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnaffiaturePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Piantagione model
   */ 
  interface PiantagioneFieldRefs {
    readonly id_piantagione: FieldRef<"Piantagione", 'Int'>
    readonly id_utente: FieldRef<"Piantagione", 'Int'>
    readonly nome: FieldRef<"Piantagione", 'String'>
    readonly n_slot: FieldRef<"Piantagione", 'Int'>
    readonly data_inizio: FieldRef<"Piantagione", 'DateTime'>
    readonly id_pianta: FieldRef<"Piantagione", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Piantagione findUnique
   */
  export type PiantagioneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piantagione
     */
    select?: PiantagioneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantagioneInclude<ExtArgs> | null
    /**
     * Filter, which Piantagione to fetch.
     */
    where: PiantagioneWhereUniqueInput
  }

  /**
   * Piantagione findUniqueOrThrow
   */
  export type PiantagioneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piantagione
     */
    select?: PiantagioneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantagioneInclude<ExtArgs> | null
    /**
     * Filter, which Piantagione to fetch.
     */
    where: PiantagioneWhereUniqueInput
  }

  /**
   * Piantagione findFirst
   */
  export type PiantagioneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piantagione
     */
    select?: PiantagioneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantagioneInclude<ExtArgs> | null
    /**
     * Filter, which Piantagione to fetch.
     */
    where?: PiantagioneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Piantagiones to fetch.
     */
    orderBy?: PiantagioneOrderByWithRelationInput | PiantagioneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Piantagiones.
     */
    cursor?: PiantagioneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Piantagiones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Piantagiones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Piantagiones.
     */
    distinct?: PiantagioneScalarFieldEnum | PiantagioneScalarFieldEnum[]
  }

  /**
   * Piantagione findFirstOrThrow
   */
  export type PiantagioneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piantagione
     */
    select?: PiantagioneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantagioneInclude<ExtArgs> | null
    /**
     * Filter, which Piantagione to fetch.
     */
    where?: PiantagioneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Piantagiones to fetch.
     */
    orderBy?: PiantagioneOrderByWithRelationInput | PiantagioneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Piantagiones.
     */
    cursor?: PiantagioneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Piantagiones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Piantagiones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Piantagiones.
     */
    distinct?: PiantagioneScalarFieldEnum | PiantagioneScalarFieldEnum[]
  }

  /**
   * Piantagione findMany
   */
  export type PiantagioneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piantagione
     */
    select?: PiantagioneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantagioneInclude<ExtArgs> | null
    /**
     * Filter, which Piantagiones to fetch.
     */
    where?: PiantagioneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Piantagiones to fetch.
     */
    orderBy?: PiantagioneOrderByWithRelationInput | PiantagioneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Piantagiones.
     */
    cursor?: PiantagioneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Piantagiones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Piantagiones.
     */
    skip?: number
    distinct?: PiantagioneScalarFieldEnum | PiantagioneScalarFieldEnum[]
  }

  /**
   * Piantagione create
   */
  export type PiantagioneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piantagione
     */
    select?: PiantagioneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantagioneInclude<ExtArgs> | null
    /**
     * The data needed to create a Piantagione.
     */
    data: XOR<PiantagioneCreateInput, PiantagioneUncheckedCreateInput>
  }

  /**
   * Piantagione createMany
   */
  export type PiantagioneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Piantagiones.
     */
    data: PiantagioneCreateManyInput | PiantagioneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Piantagione update
   */
  export type PiantagioneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piantagione
     */
    select?: PiantagioneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantagioneInclude<ExtArgs> | null
    /**
     * The data needed to update a Piantagione.
     */
    data: XOR<PiantagioneUpdateInput, PiantagioneUncheckedUpdateInput>
    /**
     * Choose, which Piantagione to update.
     */
    where: PiantagioneWhereUniqueInput
  }

  /**
   * Piantagione updateMany
   */
  export type PiantagioneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Piantagiones.
     */
    data: XOR<PiantagioneUpdateManyMutationInput, PiantagioneUncheckedUpdateManyInput>
    /**
     * Filter which Piantagiones to update
     */
    where?: PiantagioneWhereInput
  }

  /**
   * Piantagione upsert
   */
  export type PiantagioneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piantagione
     */
    select?: PiantagioneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantagioneInclude<ExtArgs> | null
    /**
     * The filter to search for the Piantagione to update in case it exists.
     */
    where: PiantagioneWhereUniqueInput
    /**
     * In case the Piantagione found by the `where` argument doesn't exist, create a new Piantagione with this data.
     */
    create: XOR<PiantagioneCreateInput, PiantagioneUncheckedCreateInput>
    /**
     * In case the Piantagione was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PiantagioneUpdateInput, PiantagioneUncheckedUpdateInput>
  }

  /**
   * Piantagione delete
   */
  export type PiantagioneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piantagione
     */
    select?: PiantagioneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantagioneInclude<ExtArgs> | null
    /**
     * Filter which Piantagione to delete.
     */
    where: PiantagioneWhereUniqueInput
  }

  /**
   * Piantagione deleteMany
   */
  export type PiantagioneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Piantagiones to delete
     */
    where?: PiantagioneWhereInput
  }

  /**
   * Piantagione.notifiche
   */
  export type Piantagione$notificheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifiche
     */
    select?: NotificheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificheInclude<ExtArgs> | null
    where?: NotificheWhereInput
    orderBy?: NotificheOrderByWithRelationInput | NotificheOrderByWithRelationInput[]
    cursor?: NotificheWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificheScalarFieldEnum | NotificheScalarFieldEnum[]
  }

  /**
   * Piantagione.annaffiature
   */
  export type Piantagione$annaffiatureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annaffiature
     */
    select?: AnnaffiatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnaffiatureInclude<ExtArgs> | null
    where?: AnnaffiatureWhereInput
    orderBy?: AnnaffiatureOrderByWithRelationInput | AnnaffiatureOrderByWithRelationInput[]
    cursor?: AnnaffiatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnaffiatureScalarFieldEnum | AnnaffiatureScalarFieldEnum[]
  }

  /**
   * Piantagione without action
   */
  export type PiantagioneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piantagione
     */
    select?: PiantagioneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantagioneInclude<ExtArgs> | null
  }


  /**
   * Model Pianta
   */

  export type AggregatePianta = {
    _count: PiantaCountAggregateOutputType | null
    _avg: PiantaAvgAggregateOutputType | null
    _sum: PiantaSumAggregateOutputType | null
    _min: PiantaMinAggregateOutputType | null
    _max: PiantaMaxAggregateOutputType | null
  }

  export type PiantaAvgAggregateOutputType = {
    id_pianta: number | null
    t_raccolta: number | null
    t_acqua: number | null
  }

  export type PiantaSumAggregateOutputType = {
    id_pianta: number | null
    t_raccolta: number | null
    t_acqua: number | null
  }

  export type PiantaMinAggregateOutputType = {
    id_pianta: number | null
    nome: string | null
    t_raccolta: number | null
    t_acqua: number | null
  }

  export type PiantaMaxAggregateOutputType = {
    id_pianta: number | null
    nome: string | null
    t_raccolta: number | null
    t_acqua: number | null
  }

  export type PiantaCountAggregateOutputType = {
    id_pianta: number
    nome: number
    t_raccolta: number
    t_acqua: number
    _all: number
  }


  export type PiantaAvgAggregateInputType = {
    id_pianta?: true
    t_raccolta?: true
    t_acqua?: true
  }

  export type PiantaSumAggregateInputType = {
    id_pianta?: true
    t_raccolta?: true
    t_acqua?: true
  }

  export type PiantaMinAggregateInputType = {
    id_pianta?: true
    nome?: true
    t_raccolta?: true
    t_acqua?: true
  }

  export type PiantaMaxAggregateInputType = {
    id_pianta?: true
    nome?: true
    t_raccolta?: true
    t_acqua?: true
  }

  export type PiantaCountAggregateInputType = {
    id_pianta?: true
    nome?: true
    t_raccolta?: true
    t_acqua?: true
    _all?: true
  }

  export type PiantaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pianta to aggregate.
     */
    where?: PiantaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Piantas to fetch.
     */
    orderBy?: PiantaOrderByWithRelationInput | PiantaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PiantaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Piantas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Piantas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Piantas
    **/
    _count?: true | PiantaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PiantaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PiantaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PiantaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PiantaMaxAggregateInputType
  }

  export type GetPiantaAggregateType<T extends PiantaAggregateArgs> = {
        [P in keyof T & keyof AggregatePianta]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePianta[P]>
      : GetScalarType<T[P], AggregatePianta[P]>
  }




  export type PiantaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PiantaWhereInput
    orderBy?: PiantaOrderByWithAggregationInput | PiantaOrderByWithAggregationInput[]
    by: PiantaScalarFieldEnum[] | PiantaScalarFieldEnum
    having?: PiantaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PiantaCountAggregateInputType | true
    _avg?: PiantaAvgAggregateInputType
    _sum?: PiantaSumAggregateInputType
    _min?: PiantaMinAggregateInputType
    _max?: PiantaMaxAggregateInputType
  }

  export type PiantaGroupByOutputType = {
    id_pianta: number
    nome: string
    t_raccolta: number
    t_acqua: number
    _count: PiantaCountAggregateOutputType | null
    _avg: PiantaAvgAggregateOutputType | null
    _sum: PiantaSumAggregateOutputType | null
    _min: PiantaMinAggregateOutputType | null
    _max: PiantaMaxAggregateOutputType | null
  }

  type GetPiantaGroupByPayload<T extends PiantaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PiantaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PiantaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PiantaGroupByOutputType[P]>
            : GetScalarType<T[P], PiantaGroupByOutputType[P]>
        }
      >
    >


  export type PiantaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_pianta?: boolean
    nome?: boolean
    t_raccolta?: boolean
    t_acqua?: boolean
    piantagioni?: boolean | Pianta$piantagioniArgs<ExtArgs>
    _count?: boolean | PiantaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pianta"]>

  export type PiantaSelectScalar = {
    id_pianta?: boolean
    nome?: boolean
    t_raccolta?: boolean
    t_acqua?: boolean
  }


  export type PiantaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    piantagioni?: boolean | Pianta$piantagioniArgs<ExtArgs>
    _count?: boolean | PiantaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PiantaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pianta"
    objects: {
      piantagioni: Prisma.$PiantagionePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_pianta: number
      nome: string
      t_raccolta: number
      t_acqua: number
    }, ExtArgs["result"]["pianta"]>
    composites: {}
  }


  type PiantaGetPayload<S extends boolean | null | undefined | PiantaDefaultArgs> = $Result.GetResult<Prisma.$PiantaPayload, S>

  type PiantaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PiantaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PiantaCountAggregateInputType | true
    }

  export interface PiantaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pianta'], meta: { name: 'Pianta' } }
    /**
     * Find zero or one Pianta that matches the filter.
     * @param {PiantaFindUniqueArgs} args - Arguments to find a Pianta
     * @example
     * // Get one Pianta
     * const pianta = await prisma.pianta.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PiantaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PiantaFindUniqueArgs<ExtArgs>>
    ): Prisma__PiantaClient<$Result.GetResult<Prisma.$PiantaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Pianta that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PiantaFindUniqueOrThrowArgs} args - Arguments to find a Pianta
     * @example
     * // Get one Pianta
     * const pianta = await prisma.pianta.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PiantaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PiantaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PiantaClient<$Result.GetResult<Prisma.$PiantaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Pianta that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PiantaFindFirstArgs} args - Arguments to find a Pianta
     * @example
     * // Get one Pianta
     * const pianta = await prisma.pianta.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PiantaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PiantaFindFirstArgs<ExtArgs>>
    ): Prisma__PiantaClient<$Result.GetResult<Prisma.$PiantaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Pianta that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PiantaFindFirstOrThrowArgs} args - Arguments to find a Pianta
     * @example
     * // Get one Pianta
     * const pianta = await prisma.pianta.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PiantaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PiantaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PiantaClient<$Result.GetResult<Prisma.$PiantaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Piantas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PiantaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Piantas
     * const piantas = await prisma.pianta.findMany()
     * 
     * // Get first 10 Piantas
     * const piantas = await prisma.pianta.findMany({ take: 10 })
     * 
     * // Only select the `id_pianta`
     * const piantaWithId_piantaOnly = await prisma.pianta.findMany({ select: { id_pianta: true } })
     * 
    **/
    findMany<T extends PiantaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PiantaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PiantaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Pianta.
     * @param {PiantaCreateArgs} args - Arguments to create a Pianta.
     * @example
     * // Create one Pianta
     * const Pianta = await prisma.pianta.create({
     *   data: {
     *     // ... data to create a Pianta
     *   }
     * })
     * 
    **/
    create<T extends PiantaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PiantaCreateArgs<ExtArgs>>
    ): Prisma__PiantaClient<$Result.GetResult<Prisma.$PiantaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Piantas.
     * @param {PiantaCreateManyArgs} args - Arguments to create many Piantas.
     * @example
     * // Create many Piantas
     * const pianta = await prisma.pianta.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends PiantaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PiantaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pianta.
     * @param {PiantaDeleteArgs} args - Arguments to delete one Pianta.
     * @example
     * // Delete one Pianta
     * const Pianta = await prisma.pianta.delete({
     *   where: {
     *     // ... filter to delete one Pianta
     *   }
     * })
     * 
    **/
    delete<T extends PiantaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PiantaDeleteArgs<ExtArgs>>
    ): Prisma__PiantaClient<$Result.GetResult<Prisma.$PiantaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Pianta.
     * @param {PiantaUpdateArgs} args - Arguments to update one Pianta.
     * @example
     * // Update one Pianta
     * const pianta = await prisma.pianta.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PiantaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PiantaUpdateArgs<ExtArgs>>
    ): Prisma__PiantaClient<$Result.GetResult<Prisma.$PiantaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Piantas.
     * @param {PiantaDeleteManyArgs} args - Arguments to filter Piantas to delete.
     * @example
     * // Delete a few Piantas
     * const { count } = await prisma.pianta.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PiantaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PiantaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Piantas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PiantaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Piantas
     * const pianta = await prisma.pianta.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PiantaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PiantaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pianta.
     * @param {PiantaUpsertArgs} args - Arguments to update or create a Pianta.
     * @example
     * // Update or create a Pianta
     * const pianta = await prisma.pianta.upsert({
     *   create: {
     *     // ... data to create a Pianta
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pianta we want to update
     *   }
     * })
    **/
    upsert<T extends PiantaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PiantaUpsertArgs<ExtArgs>>
    ): Prisma__PiantaClient<$Result.GetResult<Prisma.$PiantaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Piantas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PiantaCountArgs} args - Arguments to filter Piantas to count.
     * @example
     * // Count the number of Piantas
     * const count = await prisma.pianta.count({
     *   where: {
     *     // ... the filter for the Piantas we want to count
     *   }
     * })
    **/
    count<T extends PiantaCountArgs>(
      args?: Subset<T, PiantaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PiantaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pianta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PiantaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PiantaAggregateArgs>(args: Subset<T, PiantaAggregateArgs>): Prisma.PrismaPromise<GetPiantaAggregateType<T>>

    /**
     * Group by Pianta.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PiantaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PiantaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PiantaGroupByArgs['orderBy'] }
        : { orderBy?: PiantaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PiantaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPiantaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pianta model
   */
  readonly fields: PiantaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pianta.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PiantaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    piantagioni<T extends Pianta$piantagioniArgs<ExtArgs> = {}>(args?: Subset<T, Pianta$piantagioniArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PiantagionePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Pianta model
   */ 
  interface PiantaFieldRefs {
    readonly id_pianta: FieldRef<"Pianta", 'Int'>
    readonly nome: FieldRef<"Pianta", 'String'>
    readonly t_raccolta: FieldRef<"Pianta", 'Int'>
    readonly t_acqua: FieldRef<"Pianta", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Pianta findUnique
   */
  export type PiantaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pianta
     */
    select?: PiantaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantaInclude<ExtArgs> | null
    /**
     * Filter, which Pianta to fetch.
     */
    where: PiantaWhereUniqueInput
  }

  /**
   * Pianta findUniqueOrThrow
   */
  export type PiantaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pianta
     */
    select?: PiantaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantaInclude<ExtArgs> | null
    /**
     * Filter, which Pianta to fetch.
     */
    where: PiantaWhereUniqueInput
  }

  /**
   * Pianta findFirst
   */
  export type PiantaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pianta
     */
    select?: PiantaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantaInclude<ExtArgs> | null
    /**
     * Filter, which Pianta to fetch.
     */
    where?: PiantaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Piantas to fetch.
     */
    orderBy?: PiantaOrderByWithRelationInput | PiantaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Piantas.
     */
    cursor?: PiantaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Piantas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Piantas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Piantas.
     */
    distinct?: PiantaScalarFieldEnum | PiantaScalarFieldEnum[]
  }

  /**
   * Pianta findFirstOrThrow
   */
  export type PiantaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pianta
     */
    select?: PiantaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantaInclude<ExtArgs> | null
    /**
     * Filter, which Pianta to fetch.
     */
    where?: PiantaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Piantas to fetch.
     */
    orderBy?: PiantaOrderByWithRelationInput | PiantaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Piantas.
     */
    cursor?: PiantaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Piantas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Piantas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Piantas.
     */
    distinct?: PiantaScalarFieldEnum | PiantaScalarFieldEnum[]
  }

  /**
   * Pianta findMany
   */
  export type PiantaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pianta
     */
    select?: PiantaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantaInclude<ExtArgs> | null
    /**
     * Filter, which Piantas to fetch.
     */
    where?: PiantaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Piantas to fetch.
     */
    orderBy?: PiantaOrderByWithRelationInput | PiantaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Piantas.
     */
    cursor?: PiantaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Piantas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Piantas.
     */
    skip?: number
    distinct?: PiantaScalarFieldEnum | PiantaScalarFieldEnum[]
  }

  /**
   * Pianta create
   */
  export type PiantaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pianta
     */
    select?: PiantaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantaInclude<ExtArgs> | null
    /**
     * The data needed to create a Pianta.
     */
    data: XOR<PiantaCreateInput, PiantaUncheckedCreateInput>
  }

  /**
   * Pianta createMany
   */
  export type PiantaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Piantas.
     */
    data: PiantaCreateManyInput | PiantaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pianta update
   */
  export type PiantaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pianta
     */
    select?: PiantaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantaInclude<ExtArgs> | null
    /**
     * The data needed to update a Pianta.
     */
    data: XOR<PiantaUpdateInput, PiantaUncheckedUpdateInput>
    /**
     * Choose, which Pianta to update.
     */
    where: PiantaWhereUniqueInput
  }

  /**
   * Pianta updateMany
   */
  export type PiantaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Piantas.
     */
    data: XOR<PiantaUpdateManyMutationInput, PiantaUncheckedUpdateManyInput>
    /**
     * Filter which Piantas to update
     */
    where?: PiantaWhereInput
  }

  /**
   * Pianta upsert
   */
  export type PiantaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pianta
     */
    select?: PiantaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantaInclude<ExtArgs> | null
    /**
     * The filter to search for the Pianta to update in case it exists.
     */
    where: PiantaWhereUniqueInput
    /**
     * In case the Pianta found by the `where` argument doesn't exist, create a new Pianta with this data.
     */
    create: XOR<PiantaCreateInput, PiantaUncheckedCreateInput>
    /**
     * In case the Pianta was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PiantaUpdateInput, PiantaUncheckedUpdateInput>
  }

  /**
   * Pianta delete
   */
  export type PiantaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pianta
     */
    select?: PiantaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantaInclude<ExtArgs> | null
    /**
     * Filter which Pianta to delete.
     */
    where: PiantaWhereUniqueInput
  }

  /**
   * Pianta deleteMany
   */
  export type PiantaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Piantas to delete
     */
    where?: PiantaWhereInput
  }

  /**
   * Pianta.piantagioni
   */
  export type Pianta$piantagioniArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Piantagione
     */
    select?: PiantagioneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantagioneInclude<ExtArgs> | null
    where?: PiantagioneWhereInput
    orderBy?: PiantagioneOrderByWithRelationInput | PiantagioneOrderByWithRelationInput[]
    cursor?: PiantagioneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PiantagioneScalarFieldEnum | PiantagioneScalarFieldEnum[]
  }

  /**
   * Pianta without action
   */
  export type PiantaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pianta
     */
    select?: PiantaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PiantaInclude<ExtArgs> | null
  }


  /**
   * Model Notifiche
   */

  export type AggregateNotifiche = {
    _count: NotificheCountAggregateOutputType | null
    _avg: NotificheAvgAggregateOutputType | null
    _sum: NotificheSumAggregateOutputType | null
    _min: NotificheMinAggregateOutputType | null
    _max: NotificheMaxAggregateOutputType | null
  }

  export type NotificheAvgAggregateOutputType = {
    id_notifica: number | null
    id_utente: number | null
    id_piantagione: number | null
    tipo: number | null
  }

  export type NotificheSumAggregateOutputType = {
    id_notifica: number | null
    id_utente: number | null
    id_piantagione: number | null
    tipo: number | null
  }

  export type NotificheMinAggregateOutputType = {
    id_notifica: number | null
    testo: string | null
    aperta: boolean | null
    id_utente: number | null
    id_piantagione: number | null
    nome_piantagione: string | null
    data_invio: Date | null
    tipo: number | null
  }

  export type NotificheMaxAggregateOutputType = {
    id_notifica: number | null
    testo: string | null
    aperta: boolean | null
    id_utente: number | null
    id_piantagione: number | null
    nome_piantagione: string | null
    data_invio: Date | null
    tipo: number | null
  }

  export type NotificheCountAggregateOutputType = {
    id_notifica: number
    testo: number
    aperta: number
    id_utente: number
    id_piantagione: number
    nome_piantagione: number
    data_invio: number
    tipo: number
    _all: number
  }


  export type NotificheAvgAggregateInputType = {
    id_notifica?: true
    id_utente?: true
    id_piantagione?: true
    tipo?: true
  }

  export type NotificheSumAggregateInputType = {
    id_notifica?: true
    id_utente?: true
    id_piantagione?: true
    tipo?: true
  }

  export type NotificheMinAggregateInputType = {
    id_notifica?: true
    testo?: true
    aperta?: true
    id_utente?: true
    id_piantagione?: true
    nome_piantagione?: true
    data_invio?: true
    tipo?: true
  }

  export type NotificheMaxAggregateInputType = {
    id_notifica?: true
    testo?: true
    aperta?: true
    id_utente?: true
    id_piantagione?: true
    nome_piantagione?: true
    data_invio?: true
    tipo?: true
  }

  export type NotificheCountAggregateInputType = {
    id_notifica?: true
    testo?: true
    aperta?: true
    id_utente?: true
    id_piantagione?: true
    nome_piantagione?: true
    data_invio?: true
    tipo?: true
    _all?: true
  }

  export type NotificheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifiche to aggregate.
     */
    where?: NotificheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifiches to fetch.
     */
    orderBy?: NotificheOrderByWithRelationInput | NotificheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifiches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifiches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifiches
    **/
    _count?: true | NotificheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificheMaxAggregateInputType
  }

  export type GetNotificheAggregateType<T extends NotificheAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifiche]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifiche[P]>
      : GetScalarType<T[P], AggregateNotifiche[P]>
  }




  export type NotificheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificheWhereInput
    orderBy?: NotificheOrderByWithAggregationInput | NotificheOrderByWithAggregationInput[]
    by: NotificheScalarFieldEnum[] | NotificheScalarFieldEnum
    having?: NotificheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificheCountAggregateInputType | true
    _avg?: NotificheAvgAggregateInputType
    _sum?: NotificheSumAggregateInputType
    _min?: NotificheMinAggregateInputType
    _max?: NotificheMaxAggregateInputType
  }

  export type NotificheGroupByOutputType = {
    id_notifica: number
    testo: string
    aperta: boolean
    id_utente: number
    id_piantagione: number
    nome_piantagione: string
    data_invio: Date
    tipo: number
    _count: NotificheCountAggregateOutputType | null
    _avg: NotificheAvgAggregateOutputType | null
    _sum: NotificheSumAggregateOutputType | null
    _min: NotificheMinAggregateOutputType | null
    _max: NotificheMaxAggregateOutputType | null
  }

  type GetNotificheGroupByPayload<T extends NotificheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificheGroupByOutputType[P]>
            : GetScalarType<T[P], NotificheGroupByOutputType[P]>
        }
      >
    >


  export type NotificheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_notifica?: boolean
    testo?: boolean
    aperta?: boolean
    id_utente?: boolean
    id_piantagione?: boolean
    nome_piantagione?: boolean
    data_invio?: boolean
    tipo?: boolean
    utente?: boolean | UtenteDefaultArgs<ExtArgs>
    piantagione?: boolean | PiantagioneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifiche"]>

  export type NotificheSelectScalar = {
    id_notifica?: boolean
    testo?: boolean
    aperta?: boolean
    id_utente?: boolean
    id_piantagione?: boolean
    nome_piantagione?: boolean
    data_invio?: boolean
    tipo?: boolean
  }


  export type NotificheInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utente?: boolean | UtenteDefaultArgs<ExtArgs>
    piantagione?: boolean | PiantagioneDefaultArgs<ExtArgs>
  }


  export type $NotifichePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notifiche"
    objects: {
      utente: Prisma.$UtentePayload<ExtArgs>
      piantagione: Prisma.$PiantagionePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_notifica: number
      testo: string
      aperta: boolean
      id_utente: number
      id_piantagione: number
      nome_piantagione: string
      data_invio: Date
      tipo: number
    }, ExtArgs["result"]["notifiche"]>
    composites: {}
  }


  type NotificheGetPayload<S extends boolean | null | undefined | NotificheDefaultArgs> = $Result.GetResult<Prisma.$NotifichePayload, S>

  type NotificheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificheFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificheCountAggregateInputType | true
    }

  export interface NotificheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notifiche'], meta: { name: 'Notifiche' } }
    /**
     * Find zero or one Notifiche that matches the filter.
     * @param {NotificheFindUniqueArgs} args - Arguments to find a Notifiche
     * @example
     * // Get one Notifiche
     * const notifiche = await prisma.notifiche.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificheFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NotificheFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificheClient<$Result.GetResult<Prisma.$NotifichePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Notifiche that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificheFindUniqueOrThrowArgs} args - Arguments to find a Notifiche
     * @example
     * // Get one Notifiche
     * const notifiche = await prisma.notifiche.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificheFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificheFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificheClient<$Result.GetResult<Prisma.$NotifichePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Notifiche that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificheFindFirstArgs} args - Arguments to find a Notifiche
     * @example
     * // Get one Notifiche
     * const notifiche = await prisma.notifiche.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificheFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificheFindFirstArgs<ExtArgs>>
    ): Prisma__NotificheClient<$Result.GetResult<Prisma.$NotifichePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Notifiche that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificheFindFirstOrThrowArgs} args - Arguments to find a Notifiche
     * @example
     * // Get one Notifiche
     * const notifiche = await prisma.notifiche.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificheFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificheFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificheClient<$Result.GetResult<Prisma.$NotifichePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Notifiches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifiches
     * const notifiches = await prisma.notifiche.findMany()
     * 
     * // Get first 10 Notifiches
     * const notifiches = await prisma.notifiche.findMany({ take: 10 })
     * 
     * // Only select the `id_notifica`
     * const notificheWithId_notificaOnly = await prisma.notifiche.findMany({ select: { id_notifica: true } })
     * 
    **/
    findMany<T extends NotificheFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificheFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotifichePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Notifiche.
     * @param {NotificheCreateArgs} args - Arguments to create a Notifiche.
     * @example
     * // Create one Notifiche
     * const Notifiche = await prisma.notifiche.create({
     *   data: {
     *     // ... data to create a Notifiche
     *   }
     * })
     * 
    **/
    create<T extends NotificheCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificheCreateArgs<ExtArgs>>
    ): Prisma__NotificheClient<$Result.GetResult<Prisma.$NotifichePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Notifiches.
     * @param {NotificheCreateManyArgs} args - Arguments to create many Notifiches.
     * @example
     * // Create many Notifiches
     * const notifiche = await prisma.notifiche.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends NotificheCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificheCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notifiche.
     * @param {NotificheDeleteArgs} args - Arguments to delete one Notifiche.
     * @example
     * // Delete one Notifiche
     * const Notifiche = await prisma.notifiche.delete({
     *   where: {
     *     // ... filter to delete one Notifiche
     *   }
     * })
     * 
    **/
    delete<T extends NotificheDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NotificheDeleteArgs<ExtArgs>>
    ): Prisma__NotificheClient<$Result.GetResult<Prisma.$NotifichePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Notifiche.
     * @param {NotificheUpdateArgs} args - Arguments to update one Notifiche.
     * @example
     * // Update one Notifiche
     * const notifiche = await prisma.notifiche.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificheUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NotificheUpdateArgs<ExtArgs>>
    ): Prisma__NotificheClient<$Result.GetResult<Prisma.$NotifichePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Notifiches.
     * @param {NotificheDeleteManyArgs} args - Arguments to filter Notifiches to delete.
     * @example
     * // Delete a few Notifiches
     * const { count } = await prisma.notifiche.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificheDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NotificheDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifiches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifiches
     * const notifiche = await prisma.notifiche.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificheUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NotificheUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifiche.
     * @param {NotificheUpsertArgs} args - Arguments to update or create a Notifiche.
     * @example
     * // Update or create a Notifiche
     * const notifiche = await prisma.notifiche.upsert({
     *   create: {
     *     // ... data to create a Notifiche
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifiche we want to update
     *   }
     * })
    **/
    upsert<T extends NotificheUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NotificheUpsertArgs<ExtArgs>>
    ): Prisma__NotificheClient<$Result.GetResult<Prisma.$NotifichePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Notifiches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificheCountArgs} args - Arguments to filter Notifiches to count.
     * @example
     * // Count the number of Notifiches
     * const count = await prisma.notifiche.count({
     *   where: {
     *     // ... the filter for the Notifiches we want to count
     *   }
     * })
    **/
    count<T extends NotificheCountArgs>(
      args?: Subset<T, NotificheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifiche.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificheAggregateArgs>(args: Subset<T, NotificheAggregateArgs>): Prisma.PrismaPromise<GetNotificheAggregateType<T>>

    /**
     * Group by Notifiche.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificheGroupByArgs['orderBy'] }
        : { orderBy?: NotificheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notifiche model
   */
  readonly fields: NotificheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notifiche.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    utente<T extends UtenteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UtenteDefaultArgs<ExtArgs>>): Prisma__UtenteClient<$Result.GetResult<Prisma.$UtentePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    piantagione<T extends PiantagioneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PiantagioneDefaultArgs<ExtArgs>>): Prisma__PiantagioneClient<$Result.GetResult<Prisma.$PiantagionePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Notifiche model
   */ 
  interface NotificheFieldRefs {
    readonly id_notifica: FieldRef<"Notifiche", 'Int'>
    readonly testo: FieldRef<"Notifiche", 'String'>
    readonly aperta: FieldRef<"Notifiche", 'Boolean'>
    readonly id_utente: FieldRef<"Notifiche", 'Int'>
    readonly id_piantagione: FieldRef<"Notifiche", 'Int'>
    readonly nome_piantagione: FieldRef<"Notifiche", 'String'>
    readonly data_invio: FieldRef<"Notifiche", 'DateTime'>
    readonly tipo: FieldRef<"Notifiche", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Notifiche findUnique
   */
  export type NotificheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifiche
     */
    select?: NotificheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificheInclude<ExtArgs> | null
    /**
     * Filter, which Notifiche to fetch.
     */
    where: NotificheWhereUniqueInput
  }

  /**
   * Notifiche findUniqueOrThrow
   */
  export type NotificheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifiche
     */
    select?: NotificheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificheInclude<ExtArgs> | null
    /**
     * Filter, which Notifiche to fetch.
     */
    where: NotificheWhereUniqueInput
  }

  /**
   * Notifiche findFirst
   */
  export type NotificheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifiche
     */
    select?: NotificheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificheInclude<ExtArgs> | null
    /**
     * Filter, which Notifiche to fetch.
     */
    where?: NotificheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifiches to fetch.
     */
    orderBy?: NotificheOrderByWithRelationInput | NotificheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifiches.
     */
    cursor?: NotificheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifiches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifiches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifiches.
     */
    distinct?: NotificheScalarFieldEnum | NotificheScalarFieldEnum[]
  }

  /**
   * Notifiche findFirstOrThrow
   */
  export type NotificheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifiche
     */
    select?: NotificheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificheInclude<ExtArgs> | null
    /**
     * Filter, which Notifiche to fetch.
     */
    where?: NotificheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifiches to fetch.
     */
    orderBy?: NotificheOrderByWithRelationInput | NotificheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifiches.
     */
    cursor?: NotificheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifiches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifiches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifiches.
     */
    distinct?: NotificheScalarFieldEnum | NotificheScalarFieldEnum[]
  }

  /**
   * Notifiche findMany
   */
  export type NotificheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifiche
     */
    select?: NotificheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificheInclude<ExtArgs> | null
    /**
     * Filter, which Notifiches to fetch.
     */
    where?: NotificheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifiches to fetch.
     */
    orderBy?: NotificheOrderByWithRelationInput | NotificheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifiches.
     */
    cursor?: NotificheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifiches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifiches.
     */
    skip?: number
    distinct?: NotificheScalarFieldEnum | NotificheScalarFieldEnum[]
  }

  /**
   * Notifiche create
   */
  export type NotificheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifiche
     */
    select?: NotificheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificheInclude<ExtArgs> | null
    /**
     * The data needed to create a Notifiche.
     */
    data: XOR<NotificheCreateInput, NotificheUncheckedCreateInput>
  }

  /**
   * Notifiche createMany
   */
  export type NotificheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifiches.
     */
    data: NotificheCreateManyInput | NotificheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notifiche update
   */
  export type NotificheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifiche
     */
    select?: NotificheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificheInclude<ExtArgs> | null
    /**
     * The data needed to update a Notifiche.
     */
    data: XOR<NotificheUpdateInput, NotificheUncheckedUpdateInput>
    /**
     * Choose, which Notifiche to update.
     */
    where: NotificheWhereUniqueInput
  }

  /**
   * Notifiche updateMany
   */
  export type NotificheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifiches.
     */
    data: XOR<NotificheUpdateManyMutationInput, NotificheUncheckedUpdateManyInput>
    /**
     * Filter which Notifiches to update
     */
    where?: NotificheWhereInput
  }

  /**
   * Notifiche upsert
   */
  export type NotificheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifiche
     */
    select?: NotificheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificheInclude<ExtArgs> | null
    /**
     * The filter to search for the Notifiche to update in case it exists.
     */
    where: NotificheWhereUniqueInput
    /**
     * In case the Notifiche found by the `where` argument doesn't exist, create a new Notifiche with this data.
     */
    create: XOR<NotificheCreateInput, NotificheUncheckedCreateInput>
    /**
     * In case the Notifiche was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificheUpdateInput, NotificheUncheckedUpdateInput>
  }

  /**
   * Notifiche delete
   */
  export type NotificheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifiche
     */
    select?: NotificheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificheInclude<ExtArgs> | null
    /**
     * Filter which Notifiche to delete.
     */
    where: NotificheWhereUniqueInput
  }

  /**
   * Notifiche deleteMany
   */
  export type NotificheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifiches to delete
     */
    where?: NotificheWhereInput
  }

  /**
   * Notifiche without action
   */
  export type NotificheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifiche
     */
    select?: NotificheSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificheInclude<ExtArgs> | null
  }


  /**
   * Model Annaffiature
   */

  export type AggregateAnnaffiature = {
    _count: AnnaffiatureCountAggregateOutputType | null
    _avg: AnnaffiatureAvgAggregateOutputType | null
    _sum: AnnaffiatureSumAggregateOutputType | null
    _min: AnnaffiatureMinAggregateOutputType | null
    _max: AnnaffiatureMaxAggregateOutputType | null
  }

  export type AnnaffiatureAvgAggregateOutputType = {
    id_annaffiatura: number | null
    id_utente: number | null
    id_piantagione: number | null
    giorni_rimanenti: number | null
  }

  export type AnnaffiatureSumAggregateOutputType = {
    id_annaffiatura: number | null
    id_utente: number | null
    id_piantagione: number | null
    giorni_rimanenti: number | null
  }

  export type AnnaffiatureMinAggregateOutputType = {
    id_annaffiatura: number | null
    id_utente: number | null
    id_piantagione: number | null
    giorni_rimanenti: number | null
    data_save: Date | null
  }

  export type AnnaffiatureMaxAggregateOutputType = {
    id_annaffiatura: number | null
    id_utente: number | null
    id_piantagione: number | null
    giorni_rimanenti: number | null
    data_save: Date | null
  }

  export type AnnaffiatureCountAggregateOutputType = {
    id_annaffiatura: number
    id_utente: number
    id_piantagione: number
    giorni_rimanenti: number
    data_save: number
    _all: number
  }


  export type AnnaffiatureAvgAggregateInputType = {
    id_annaffiatura?: true
    id_utente?: true
    id_piantagione?: true
    giorni_rimanenti?: true
  }

  export type AnnaffiatureSumAggregateInputType = {
    id_annaffiatura?: true
    id_utente?: true
    id_piantagione?: true
    giorni_rimanenti?: true
  }

  export type AnnaffiatureMinAggregateInputType = {
    id_annaffiatura?: true
    id_utente?: true
    id_piantagione?: true
    giorni_rimanenti?: true
    data_save?: true
  }

  export type AnnaffiatureMaxAggregateInputType = {
    id_annaffiatura?: true
    id_utente?: true
    id_piantagione?: true
    giorni_rimanenti?: true
    data_save?: true
  }

  export type AnnaffiatureCountAggregateInputType = {
    id_annaffiatura?: true
    id_utente?: true
    id_piantagione?: true
    giorni_rimanenti?: true
    data_save?: true
    _all?: true
  }

  export type AnnaffiatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Annaffiature to aggregate.
     */
    where?: AnnaffiatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annaffiatures to fetch.
     */
    orderBy?: AnnaffiatureOrderByWithRelationInput | AnnaffiatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnaffiatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annaffiatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annaffiatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Annaffiatures
    **/
    _count?: true | AnnaffiatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnnaffiatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnnaffiatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnaffiatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnaffiatureMaxAggregateInputType
  }

  export type GetAnnaffiatureAggregateType<T extends AnnaffiatureAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnaffiature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnaffiature[P]>
      : GetScalarType<T[P], AggregateAnnaffiature[P]>
  }




  export type AnnaffiatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnaffiatureWhereInput
    orderBy?: AnnaffiatureOrderByWithAggregationInput | AnnaffiatureOrderByWithAggregationInput[]
    by: AnnaffiatureScalarFieldEnum[] | AnnaffiatureScalarFieldEnum
    having?: AnnaffiatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnaffiatureCountAggregateInputType | true
    _avg?: AnnaffiatureAvgAggregateInputType
    _sum?: AnnaffiatureSumAggregateInputType
    _min?: AnnaffiatureMinAggregateInputType
    _max?: AnnaffiatureMaxAggregateInputType
  }

  export type AnnaffiatureGroupByOutputType = {
    id_annaffiatura: number
    id_utente: number
    id_piantagione: number
    giorni_rimanenti: number
    data_save: Date
    _count: AnnaffiatureCountAggregateOutputType | null
    _avg: AnnaffiatureAvgAggregateOutputType | null
    _sum: AnnaffiatureSumAggregateOutputType | null
    _min: AnnaffiatureMinAggregateOutputType | null
    _max: AnnaffiatureMaxAggregateOutputType | null
  }

  type GetAnnaffiatureGroupByPayload<T extends AnnaffiatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnaffiatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnaffiatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnaffiatureGroupByOutputType[P]>
            : GetScalarType<T[P], AnnaffiatureGroupByOutputType[P]>
        }
      >
    >


  export type AnnaffiatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_annaffiatura?: boolean
    id_utente?: boolean
    id_piantagione?: boolean
    giorni_rimanenti?: boolean
    data_save?: boolean
    utente?: boolean | UtenteDefaultArgs<ExtArgs>
    piantagione?: boolean | PiantagioneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["annaffiature"]>

  export type AnnaffiatureSelectScalar = {
    id_annaffiatura?: boolean
    id_utente?: boolean
    id_piantagione?: boolean
    giorni_rimanenti?: boolean
    data_save?: boolean
  }


  export type AnnaffiatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utente?: boolean | UtenteDefaultArgs<ExtArgs>
    piantagione?: boolean | PiantagioneDefaultArgs<ExtArgs>
  }


  export type $AnnaffiaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Annaffiature"
    objects: {
      utente: Prisma.$UtentePayload<ExtArgs>
      piantagione: Prisma.$PiantagionePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_annaffiatura: number
      id_utente: number
      id_piantagione: number
      giorni_rimanenti: number
      data_save: Date
    }, ExtArgs["result"]["annaffiature"]>
    composites: {}
  }


  type AnnaffiatureGetPayload<S extends boolean | null | undefined | AnnaffiatureDefaultArgs> = $Result.GetResult<Prisma.$AnnaffiaturePayload, S>

  type AnnaffiatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnnaffiatureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnnaffiatureCountAggregateInputType | true
    }

  export interface AnnaffiatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Annaffiature'], meta: { name: 'Annaffiature' } }
    /**
     * Find zero or one Annaffiature that matches the filter.
     * @param {AnnaffiatureFindUniqueArgs} args - Arguments to find a Annaffiature
     * @example
     * // Get one Annaffiature
     * const annaffiature = await prisma.annaffiature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AnnaffiatureFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AnnaffiatureFindUniqueArgs<ExtArgs>>
    ): Prisma__AnnaffiatureClient<$Result.GetResult<Prisma.$AnnaffiaturePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Annaffiature that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnnaffiatureFindUniqueOrThrowArgs} args - Arguments to find a Annaffiature
     * @example
     * // Get one Annaffiature
     * const annaffiature = await prisma.annaffiature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AnnaffiatureFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AnnaffiatureFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AnnaffiatureClient<$Result.GetResult<Prisma.$AnnaffiaturePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Annaffiature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnaffiatureFindFirstArgs} args - Arguments to find a Annaffiature
     * @example
     * // Get one Annaffiature
     * const annaffiature = await prisma.annaffiature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AnnaffiatureFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AnnaffiatureFindFirstArgs<ExtArgs>>
    ): Prisma__AnnaffiatureClient<$Result.GetResult<Prisma.$AnnaffiaturePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Annaffiature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnaffiatureFindFirstOrThrowArgs} args - Arguments to find a Annaffiature
     * @example
     * // Get one Annaffiature
     * const annaffiature = await prisma.annaffiature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AnnaffiatureFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AnnaffiatureFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AnnaffiatureClient<$Result.GetResult<Prisma.$AnnaffiaturePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Annaffiatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnaffiatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Annaffiatures
     * const annaffiatures = await prisma.annaffiature.findMany()
     * 
     * // Get first 10 Annaffiatures
     * const annaffiatures = await prisma.annaffiature.findMany({ take: 10 })
     * 
     * // Only select the `id_annaffiatura`
     * const annaffiatureWithId_annaffiaturaOnly = await prisma.annaffiature.findMany({ select: { id_annaffiatura: true } })
     * 
    **/
    findMany<T extends AnnaffiatureFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnnaffiatureFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnaffiaturePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Annaffiature.
     * @param {AnnaffiatureCreateArgs} args - Arguments to create a Annaffiature.
     * @example
     * // Create one Annaffiature
     * const Annaffiature = await prisma.annaffiature.create({
     *   data: {
     *     // ... data to create a Annaffiature
     *   }
     * })
     * 
    **/
    create<T extends AnnaffiatureCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AnnaffiatureCreateArgs<ExtArgs>>
    ): Prisma__AnnaffiatureClient<$Result.GetResult<Prisma.$AnnaffiaturePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Annaffiatures.
     * @param {AnnaffiatureCreateManyArgs} args - Arguments to create many Annaffiatures.
     * @example
     * // Create many Annaffiatures
     * const annaffiature = await prisma.annaffiature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AnnaffiatureCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnnaffiatureCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Annaffiature.
     * @param {AnnaffiatureDeleteArgs} args - Arguments to delete one Annaffiature.
     * @example
     * // Delete one Annaffiature
     * const Annaffiature = await prisma.annaffiature.delete({
     *   where: {
     *     // ... filter to delete one Annaffiature
     *   }
     * })
     * 
    **/
    delete<T extends AnnaffiatureDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AnnaffiatureDeleteArgs<ExtArgs>>
    ): Prisma__AnnaffiatureClient<$Result.GetResult<Prisma.$AnnaffiaturePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Annaffiature.
     * @param {AnnaffiatureUpdateArgs} args - Arguments to update one Annaffiature.
     * @example
     * // Update one Annaffiature
     * const annaffiature = await prisma.annaffiature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AnnaffiatureUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AnnaffiatureUpdateArgs<ExtArgs>>
    ): Prisma__AnnaffiatureClient<$Result.GetResult<Prisma.$AnnaffiaturePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Annaffiatures.
     * @param {AnnaffiatureDeleteManyArgs} args - Arguments to filter Annaffiatures to delete.
     * @example
     * // Delete a few Annaffiatures
     * const { count } = await prisma.annaffiature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AnnaffiatureDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnnaffiatureDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Annaffiatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnaffiatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Annaffiatures
     * const annaffiature = await prisma.annaffiature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AnnaffiatureUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AnnaffiatureUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Annaffiature.
     * @param {AnnaffiatureUpsertArgs} args - Arguments to update or create a Annaffiature.
     * @example
     * // Update or create a Annaffiature
     * const annaffiature = await prisma.annaffiature.upsert({
     *   create: {
     *     // ... data to create a Annaffiature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Annaffiature we want to update
     *   }
     * })
    **/
    upsert<T extends AnnaffiatureUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AnnaffiatureUpsertArgs<ExtArgs>>
    ): Prisma__AnnaffiatureClient<$Result.GetResult<Prisma.$AnnaffiaturePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Annaffiatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnaffiatureCountArgs} args - Arguments to filter Annaffiatures to count.
     * @example
     * // Count the number of Annaffiatures
     * const count = await prisma.annaffiature.count({
     *   where: {
     *     // ... the filter for the Annaffiatures we want to count
     *   }
     * })
    **/
    count<T extends AnnaffiatureCountArgs>(
      args?: Subset<T, AnnaffiatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnaffiatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Annaffiature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnaffiatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnaffiatureAggregateArgs>(args: Subset<T, AnnaffiatureAggregateArgs>): Prisma.PrismaPromise<GetAnnaffiatureAggregateType<T>>

    /**
     * Group by Annaffiature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnaffiatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnaffiatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnaffiatureGroupByArgs['orderBy'] }
        : { orderBy?: AnnaffiatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnaffiatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnaffiatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Annaffiature model
   */
  readonly fields: AnnaffiatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Annaffiature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnaffiatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    utente<T extends UtenteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UtenteDefaultArgs<ExtArgs>>): Prisma__UtenteClient<$Result.GetResult<Prisma.$UtentePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    piantagione<T extends PiantagioneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PiantagioneDefaultArgs<ExtArgs>>): Prisma__PiantagioneClient<$Result.GetResult<Prisma.$PiantagionePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Annaffiature model
   */ 
  interface AnnaffiatureFieldRefs {
    readonly id_annaffiatura: FieldRef<"Annaffiature", 'Int'>
    readonly id_utente: FieldRef<"Annaffiature", 'Int'>
    readonly id_piantagione: FieldRef<"Annaffiature", 'Int'>
    readonly giorni_rimanenti: FieldRef<"Annaffiature", 'Int'>
    readonly data_save: FieldRef<"Annaffiature", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Annaffiature findUnique
   */
  export type AnnaffiatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annaffiature
     */
    select?: AnnaffiatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnaffiatureInclude<ExtArgs> | null
    /**
     * Filter, which Annaffiature to fetch.
     */
    where: AnnaffiatureWhereUniqueInput
  }

  /**
   * Annaffiature findUniqueOrThrow
   */
  export type AnnaffiatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annaffiature
     */
    select?: AnnaffiatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnaffiatureInclude<ExtArgs> | null
    /**
     * Filter, which Annaffiature to fetch.
     */
    where: AnnaffiatureWhereUniqueInput
  }

  /**
   * Annaffiature findFirst
   */
  export type AnnaffiatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annaffiature
     */
    select?: AnnaffiatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnaffiatureInclude<ExtArgs> | null
    /**
     * Filter, which Annaffiature to fetch.
     */
    where?: AnnaffiatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annaffiatures to fetch.
     */
    orderBy?: AnnaffiatureOrderByWithRelationInput | AnnaffiatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Annaffiatures.
     */
    cursor?: AnnaffiatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annaffiatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annaffiatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Annaffiatures.
     */
    distinct?: AnnaffiatureScalarFieldEnum | AnnaffiatureScalarFieldEnum[]
  }

  /**
   * Annaffiature findFirstOrThrow
   */
  export type AnnaffiatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annaffiature
     */
    select?: AnnaffiatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnaffiatureInclude<ExtArgs> | null
    /**
     * Filter, which Annaffiature to fetch.
     */
    where?: AnnaffiatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annaffiatures to fetch.
     */
    orderBy?: AnnaffiatureOrderByWithRelationInput | AnnaffiatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Annaffiatures.
     */
    cursor?: AnnaffiatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annaffiatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annaffiatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Annaffiatures.
     */
    distinct?: AnnaffiatureScalarFieldEnum | AnnaffiatureScalarFieldEnum[]
  }

  /**
   * Annaffiature findMany
   */
  export type AnnaffiatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annaffiature
     */
    select?: AnnaffiatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnaffiatureInclude<ExtArgs> | null
    /**
     * Filter, which Annaffiatures to fetch.
     */
    where?: AnnaffiatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Annaffiatures to fetch.
     */
    orderBy?: AnnaffiatureOrderByWithRelationInput | AnnaffiatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Annaffiatures.
     */
    cursor?: AnnaffiatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Annaffiatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Annaffiatures.
     */
    skip?: number
    distinct?: AnnaffiatureScalarFieldEnum | AnnaffiatureScalarFieldEnum[]
  }

  /**
   * Annaffiature create
   */
  export type AnnaffiatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annaffiature
     */
    select?: AnnaffiatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnaffiatureInclude<ExtArgs> | null
    /**
     * The data needed to create a Annaffiature.
     */
    data: XOR<AnnaffiatureCreateInput, AnnaffiatureUncheckedCreateInput>
  }

  /**
   * Annaffiature createMany
   */
  export type AnnaffiatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Annaffiatures.
     */
    data: AnnaffiatureCreateManyInput | AnnaffiatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Annaffiature update
   */
  export type AnnaffiatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annaffiature
     */
    select?: AnnaffiatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnaffiatureInclude<ExtArgs> | null
    /**
     * The data needed to update a Annaffiature.
     */
    data: XOR<AnnaffiatureUpdateInput, AnnaffiatureUncheckedUpdateInput>
    /**
     * Choose, which Annaffiature to update.
     */
    where: AnnaffiatureWhereUniqueInput
  }

  /**
   * Annaffiature updateMany
   */
  export type AnnaffiatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Annaffiatures.
     */
    data: XOR<AnnaffiatureUpdateManyMutationInput, AnnaffiatureUncheckedUpdateManyInput>
    /**
     * Filter which Annaffiatures to update
     */
    where?: AnnaffiatureWhereInput
  }

  /**
   * Annaffiature upsert
   */
  export type AnnaffiatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annaffiature
     */
    select?: AnnaffiatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnaffiatureInclude<ExtArgs> | null
    /**
     * The filter to search for the Annaffiature to update in case it exists.
     */
    where: AnnaffiatureWhereUniqueInput
    /**
     * In case the Annaffiature found by the `where` argument doesn't exist, create a new Annaffiature with this data.
     */
    create: XOR<AnnaffiatureCreateInput, AnnaffiatureUncheckedCreateInput>
    /**
     * In case the Annaffiature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnaffiatureUpdateInput, AnnaffiatureUncheckedUpdateInput>
  }

  /**
   * Annaffiature delete
   */
  export type AnnaffiatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annaffiature
     */
    select?: AnnaffiatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnaffiatureInclude<ExtArgs> | null
    /**
     * Filter which Annaffiature to delete.
     */
    where: AnnaffiatureWhereUniqueInput
  }

  /**
   * Annaffiature deleteMany
   */
  export type AnnaffiatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Annaffiatures to delete
     */
    where?: AnnaffiatureWhereInput
  }

  /**
   * Annaffiature without action
   */
  export type AnnaffiatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Annaffiature
     */
    select?: AnnaffiatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnaffiatureInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UtenteScalarFieldEnum: {
    id_utente: 'id_utente',
    nome: 'nome',
    cognome: 'cognome'
  };

  export type UtenteScalarFieldEnum = (typeof UtenteScalarFieldEnum)[keyof typeof UtenteScalarFieldEnum]


  export const CredenzialiScalarFieldEnum: {
    id_utente: 'id_utente',
    email: 'email',
    password: 'password'
  };

  export type CredenzialiScalarFieldEnum = (typeof CredenzialiScalarFieldEnum)[keyof typeof CredenzialiScalarFieldEnum]


  export const PiantagioneScalarFieldEnum: {
    id_piantagione: 'id_piantagione',
    id_utente: 'id_utente',
    nome: 'nome',
    n_slot: 'n_slot',
    data_inizio: 'data_inizio',
    id_pianta: 'id_pianta'
  };

  export type PiantagioneScalarFieldEnum = (typeof PiantagioneScalarFieldEnum)[keyof typeof PiantagioneScalarFieldEnum]


  export const PiantaScalarFieldEnum: {
    id_pianta: 'id_pianta',
    nome: 'nome',
    t_raccolta: 't_raccolta',
    t_acqua: 't_acqua'
  };

  export type PiantaScalarFieldEnum = (typeof PiantaScalarFieldEnum)[keyof typeof PiantaScalarFieldEnum]


  export const NotificheScalarFieldEnum: {
    id_notifica: 'id_notifica',
    testo: 'testo',
    aperta: 'aperta',
    id_utente: 'id_utente',
    id_piantagione: 'id_piantagione',
    nome_piantagione: 'nome_piantagione',
    data_invio: 'data_invio',
    tipo: 'tipo'
  };

  export type NotificheScalarFieldEnum = (typeof NotificheScalarFieldEnum)[keyof typeof NotificheScalarFieldEnum]


  export const AnnaffiatureScalarFieldEnum: {
    id_annaffiatura: 'id_annaffiatura',
    id_utente: 'id_utente',
    id_piantagione: 'id_piantagione',
    giorni_rimanenti: 'giorni_rimanenti',
    data_save: 'data_save'
  };

  export type AnnaffiatureScalarFieldEnum = (typeof AnnaffiatureScalarFieldEnum)[keyof typeof AnnaffiatureScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UtenteWhereInput = {
    AND?: UtenteWhereInput | UtenteWhereInput[]
    OR?: UtenteWhereInput[]
    NOT?: UtenteWhereInput | UtenteWhereInput[]
    id_utente?: IntFilter<"Utente"> | number
    nome?: StringFilter<"Utente"> | string
    cognome?: StringFilter<"Utente"> | string
    credenziali?: XOR<CredenzialiNullableRelationFilter, CredenzialiWhereInput> | null
    piantagioni?: PiantagioneListRelationFilter
    notifiche?: NotificheListRelationFilter
    annaffiature?: AnnaffiatureListRelationFilter
  }

  export type UtenteOrderByWithRelationInput = {
    id_utente?: SortOrder
    nome?: SortOrder
    cognome?: SortOrder
    credenziali?: CredenzialiOrderByWithRelationInput
    piantagioni?: PiantagioneOrderByRelationAggregateInput
    notifiche?: NotificheOrderByRelationAggregateInput
    annaffiature?: AnnaffiatureOrderByRelationAggregateInput
  }

  export type UtenteWhereUniqueInput = Prisma.AtLeast<{
    id_utente?: number
    AND?: UtenteWhereInput | UtenteWhereInput[]
    OR?: UtenteWhereInput[]
    NOT?: UtenteWhereInput | UtenteWhereInput[]
    nome?: StringFilter<"Utente"> | string
    cognome?: StringFilter<"Utente"> | string
    credenziali?: XOR<CredenzialiNullableRelationFilter, CredenzialiWhereInput> | null
    piantagioni?: PiantagioneListRelationFilter
    notifiche?: NotificheListRelationFilter
    annaffiature?: AnnaffiatureListRelationFilter
  }, "id_utente">

  export type UtenteOrderByWithAggregationInput = {
    id_utente?: SortOrder
    nome?: SortOrder
    cognome?: SortOrder
    _count?: UtenteCountOrderByAggregateInput
    _avg?: UtenteAvgOrderByAggregateInput
    _max?: UtenteMaxOrderByAggregateInput
    _min?: UtenteMinOrderByAggregateInput
    _sum?: UtenteSumOrderByAggregateInput
  }

  export type UtenteScalarWhereWithAggregatesInput = {
    AND?: UtenteScalarWhereWithAggregatesInput | UtenteScalarWhereWithAggregatesInput[]
    OR?: UtenteScalarWhereWithAggregatesInput[]
    NOT?: UtenteScalarWhereWithAggregatesInput | UtenteScalarWhereWithAggregatesInput[]
    id_utente?: IntWithAggregatesFilter<"Utente"> | number
    nome?: StringWithAggregatesFilter<"Utente"> | string
    cognome?: StringWithAggregatesFilter<"Utente"> | string
  }

  export type CredenzialiWhereInput = {
    AND?: CredenzialiWhereInput | CredenzialiWhereInput[]
    OR?: CredenzialiWhereInput[]
    NOT?: CredenzialiWhereInput | CredenzialiWhereInput[]
    id_utente?: IntFilter<"Credenziali"> | number
    email?: StringFilter<"Credenziali"> | string
    password?: StringFilter<"Credenziali"> | string
    utente?: XOR<UtenteRelationFilter, UtenteWhereInput>
  }

  export type CredenzialiOrderByWithRelationInput = {
    id_utente?: SortOrder
    email?: SortOrder
    password?: SortOrder
    utente?: UtenteOrderByWithRelationInput
  }

  export type CredenzialiWhereUniqueInput = Prisma.AtLeast<{
    id_utente?: number
    email?: string
    AND?: CredenzialiWhereInput | CredenzialiWhereInput[]
    OR?: CredenzialiWhereInput[]
    NOT?: CredenzialiWhereInput | CredenzialiWhereInput[]
    password?: StringFilter<"Credenziali"> | string
    utente?: XOR<UtenteRelationFilter, UtenteWhereInput>
  }, "id_utente" | "email">

  export type CredenzialiOrderByWithAggregationInput = {
    id_utente?: SortOrder
    email?: SortOrder
    password?: SortOrder
    _count?: CredenzialiCountOrderByAggregateInput
    _avg?: CredenzialiAvgOrderByAggregateInput
    _max?: CredenzialiMaxOrderByAggregateInput
    _min?: CredenzialiMinOrderByAggregateInput
    _sum?: CredenzialiSumOrderByAggregateInput
  }

  export type CredenzialiScalarWhereWithAggregatesInput = {
    AND?: CredenzialiScalarWhereWithAggregatesInput | CredenzialiScalarWhereWithAggregatesInput[]
    OR?: CredenzialiScalarWhereWithAggregatesInput[]
    NOT?: CredenzialiScalarWhereWithAggregatesInput | CredenzialiScalarWhereWithAggregatesInput[]
    id_utente?: IntWithAggregatesFilter<"Credenziali"> | number
    email?: StringWithAggregatesFilter<"Credenziali"> | string
    password?: StringWithAggregatesFilter<"Credenziali"> | string
  }

  export type PiantagioneWhereInput = {
    AND?: PiantagioneWhereInput | PiantagioneWhereInput[]
    OR?: PiantagioneWhereInput[]
    NOT?: PiantagioneWhereInput | PiantagioneWhereInput[]
    id_piantagione?: IntFilter<"Piantagione"> | number
    id_utente?: IntFilter<"Piantagione"> | number
    nome?: StringFilter<"Piantagione"> | string
    n_slot?: IntFilter<"Piantagione"> | number
    data_inizio?: DateTimeFilter<"Piantagione"> | Date | string
    id_pianta?: IntFilter<"Piantagione"> | number
    utente?: XOR<UtenteRelationFilter, UtenteWhereInput>
    pianta?: XOR<PiantaRelationFilter, PiantaWhereInput>
    notifiche?: NotificheListRelationFilter
    annaffiature?: AnnaffiatureListRelationFilter
  }

  export type PiantagioneOrderByWithRelationInput = {
    id_piantagione?: SortOrder
    id_utente?: SortOrder
    nome?: SortOrder
    n_slot?: SortOrder
    data_inizio?: SortOrder
    id_pianta?: SortOrder
    utente?: UtenteOrderByWithRelationInput
    pianta?: PiantaOrderByWithRelationInput
    notifiche?: NotificheOrderByRelationAggregateInput
    annaffiature?: AnnaffiatureOrderByRelationAggregateInput
  }

  export type PiantagioneWhereUniqueInput = Prisma.AtLeast<{
    id_piantagione?: number
    AND?: PiantagioneWhereInput | PiantagioneWhereInput[]
    OR?: PiantagioneWhereInput[]
    NOT?: PiantagioneWhereInput | PiantagioneWhereInput[]
    id_utente?: IntFilter<"Piantagione"> | number
    nome?: StringFilter<"Piantagione"> | string
    n_slot?: IntFilter<"Piantagione"> | number
    data_inizio?: DateTimeFilter<"Piantagione"> | Date | string
    id_pianta?: IntFilter<"Piantagione"> | number
    utente?: XOR<UtenteRelationFilter, UtenteWhereInput>
    pianta?: XOR<PiantaRelationFilter, PiantaWhereInput>
    notifiche?: NotificheListRelationFilter
    annaffiature?: AnnaffiatureListRelationFilter
  }, "id_piantagione">

  export type PiantagioneOrderByWithAggregationInput = {
    id_piantagione?: SortOrder
    id_utente?: SortOrder
    nome?: SortOrder
    n_slot?: SortOrder
    data_inizio?: SortOrder
    id_pianta?: SortOrder
    _count?: PiantagioneCountOrderByAggregateInput
    _avg?: PiantagioneAvgOrderByAggregateInput
    _max?: PiantagioneMaxOrderByAggregateInput
    _min?: PiantagioneMinOrderByAggregateInput
    _sum?: PiantagioneSumOrderByAggregateInput
  }

  export type PiantagioneScalarWhereWithAggregatesInput = {
    AND?: PiantagioneScalarWhereWithAggregatesInput | PiantagioneScalarWhereWithAggregatesInput[]
    OR?: PiantagioneScalarWhereWithAggregatesInput[]
    NOT?: PiantagioneScalarWhereWithAggregatesInput | PiantagioneScalarWhereWithAggregatesInput[]
    id_piantagione?: IntWithAggregatesFilter<"Piantagione"> | number
    id_utente?: IntWithAggregatesFilter<"Piantagione"> | number
    nome?: StringWithAggregatesFilter<"Piantagione"> | string
    n_slot?: IntWithAggregatesFilter<"Piantagione"> | number
    data_inizio?: DateTimeWithAggregatesFilter<"Piantagione"> | Date | string
    id_pianta?: IntWithAggregatesFilter<"Piantagione"> | number
  }

  export type PiantaWhereInput = {
    AND?: PiantaWhereInput | PiantaWhereInput[]
    OR?: PiantaWhereInput[]
    NOT?: PiantaWhereInput | PiantaWhereInput[]
    id_pianta?: IntFilter<"Pianta"> | number
    nome?: StringFilter<"Pianta"> | string
    t_raccolta?: IntFilter<"Pianta"> | number
    t_acqua?: IntFilter<"Pianta"> | number
    piantagioni?: PiantagioneListRelationFilter
  }

  export type PiantaOrderByWithRelationInput = {
    id_pianta?: SortOrder
    nome?: SortOrder
    t_raccolta?: SortOrder
    t_acqua?: SortOrder
    piantagioni?: PiantagioneOrderByRelationAggregateInput
  }

  export type PiantaWhereUniqueInput = Prisma.AtLeast<{
    id_pianta?: number
    AND?: PiantaWhereInput | PiantaWhereInput[]
    OR?: PiantaWhereInput[]
    NOT?: PiantaWhereInput | PiantaWhereInput[]
    nome?: StringFilter<"Pianta"> | string
    t_raccolta?: IntFilter<"Pianta"> | number
    t_acqua?: IntFilter<"Pianta"> | number
    piantagioni?: PiantagioneListRelationFilter
  }, "id_pianta">

  export type PiantaOrderByWithAggregationInput = {
    id_pianta?: SortOrder
    nome?: SortOrder
    t_raccolta?: SortOrder
    t_acqua?: SortOrder
    _count?: PiantaCountOrderByAggregateInput
    _avg?: PiantaAvgOrderByAggregateInput
    _max?: PiantaMaxOrderByAggregateInput
    _min?: PiantaMinOrderByAggregateInput
    _sum?: PiantaSumOrderByAggregateInput
  }

  export type PiantaScalarWhereWithAggregatesInput = {
    AND?: PiantaScalarWhereWithAggregatesInput | PiantaScalarWhereWithAggregatesInput[]
    OR?: PiantaScalarWhereWithAggregatesInput[]
    NOT?: PiantaScalarWhereWithAggregatesInput | PiantaScalarWhereWithAggregatesInput[]
    id_pianta?: IntWithAggregatesFilter<"Pianta"> | number
    nome?: StringWithAggregatesFilter<"Pianta"> | string
    t_raccolta?: IntWithAggregatesFilter<"Pianta"> | number
    t_acqua?: IntWithAggregatesFilter<"Pianta"> | number
  }

  export type NotificheWhereInput = {
    AND?: NotificheWhereInput | NotificheWhereInput[]
    OR?: NotificheWhereInput[]
    NOT?: NotificheWhereInput | NotificheWhereInput[]
    id_notifica?: IntFilter<"Notifiche"> | number
    testo?: StringFilter<"Notifiche"> | string
    aperta?: BoolFilter<"Notifiche"> | boolean
    id_utente?: IntFilter<"Notifiche"> | number
    id_piantagione?: IntFilter<"Notifiche"> | number
    nome_piantagione?: StringFilter<"Notifiche"> | string
    data_invio?: DateTimeFilter<"Notifiche"> | Date | string
    tipo?: IntFilter<"Notifiche"> | number
    utente?: XOR<UtenteRelationFilter, UtenteWhereInput>
    piantagione?: XOR<PiantagioneRelationFilter, PiantagioneWhereInput>
  }

  export type NotificheOrderByWithRelationInput = {
    id_notifica?: SortOrder
    testo?: SortOrder
    aperta?: SortOrder
    id_utente?: SortOrder
    id_piantagione?: SortOrder
    nome_piantagione?: SortOrder
    data_invio?: SortOrder
    tipo?: SortOrder
    utente?: UtenteOrderByWithRelationInput
    piantagione?: PiantagioneOrderByWithRelationInput
  }

  export type NotificheWhereUniqueInput = Prisma.AtLeast<{
    id_notifica?: number
    AND?: NotificheWhereInput | NotificheWhereInput[]
    OR?: NotificheWhereInput[]
    NOT?: NotificheWhereInput | NotificheWhereInput[]
    testo?: StringFilter<"Notifiche"> | string
    aperta?: BoolFilter<"Notifiche"> | boolean
    id_utente?: IntFilter<"Notifiche"> | number
    id_piantagione?: IntFilter<"Notifiche"> | number
    nome_piantagione?: StringFilter<"Notifiche"> | string
    data_invio?: DateTimeFilter<"Notifiche"> | Date | string
    tipo?: IntFilter<"Notifiche"> | number
    utente?: XOR<UtenteRelationFilter, UtenteWhereInput>
    piantagione?: XOR<PiantagioneRelationFilter, PiantagioneWhereInput>
  }, "id_notifica">

  export type NotificheOrderByWithAggregationInput = {
    id_notifica?: SortOrder
    testo?: SortOrder
    aperta?: SortOrder
    id_utente?: SortOrder
    id_piantagione?: SortOrder
    nome_piantagione?: SortOrder
    data_invio?: SortOrder
    tipo?: SortOrder
    _count?: NotificheCountOrderByAggregateInput
    _avg?: NotificheAvgOrderByAggregateInput
    _max?: NotificheMaxOrderByAggregateInput
    _min?: NotificheMinOrderByAggregateInput
    _sum?: NotificheSumOrderByAggregateInput
  }

  export type NotificheScalarWhereWithAggregatesInput = {
    AND?: NotificheScalarWhereWithAggregatesInput | NotificheScalarWhereWithAggregatesInput[]
    OR?: NotificheScalarWhereWithAggregatesInput[]
    NOT?: NotificheScalarWhereWithAggregatesInput | NotificheScalarWhereWithAggregatesInput[]
    id_notifica?: IntWithAggregatesFilter<"Notifiche"> | number
    testo?: StringWithAggregatesFilter<"Notifiche"> | string
    aperta?: BoolWithAggregatesFilter<"Notifiche"> | boolean
    id_utente?: IntWithAggregatesFilter<"Notifiche"> | number
    id_piantagione?: IntWithAggregatesFilter<"Notifiche"> | number
    nome_piantagione?: StringWithAggregatesFilter<"Notifiche"> | string
    data_invio?: DateTimeWithAggregatesFilter<"Notifiche"> | Date | string
    tipo?: IntWithAggregatesFilter<"Notifiche"> | number
  }

  export type AnnaffiatureWhereInput = {
    AND?: AnnaffiatureWhereInput | AnnaffiatureWhereInput[]
    OR?: AnnaffiatureWhereInput[]
    NOT?: AnnaffiatureWhereInput | AnnaffiatureWhereInput[]
    id_annaffiatura?: IntFilter<"Annaffiature"> | number
    id_utente?: IntFilter<"Annaffiature"> | number
    id_piantagione?: IntFilter<"Annaffiature"> | number
    giorni_rimanenti?: IntFilter<"Annaffiature"> | number
    data_save?: DateTimeFilter<"Annaffiature"> | Date | string
    utente?: XOR<UtenteRelationFilter, UtenteWhereInput>
    piantagione?: XOR<PiantagioneRelationFilter, PiantagioneWhereInput>
  }

  export type AnnaffiatureOrderByWithRelationInput = {
    id_annaffiatura?: SortOrder
    id_utente?: SortOrder
    id_piantagione?: SortOrder
    giorni_rimanenti?: SortOrder
    data_save?: SortOrder
    utente?: UtenteOrderByWithRelationInput
    piantagione?: PiantagioneOrderByWithRelationInput
  }

  export type AnnaffiatureWhereUniqueInput = Prisma.AtLeast<{
    id_annaffiatura?: number
    AND?: AnnaffiatureWhereInput | AnnaffiatureWhereInput[]
    OR?: AnnaffiatureWhereInput[]
    NOT?: AnnaffiatureWhereInput | AnnaffiatureWhereInput[]
    id_utente?: IntFilter<"Annaffiature"> | number
    id_piantagione?: IntFilter<"Annaffiature"> | number
    giorni_rimanenti?: IntFilter<"Annaffiature"> | number
    data_save?: DateTimeFilter<"Annaffiature"> | Date | string
    utente?: XOR<UtenteRelationFilter, UtenteWhereInput>
    piantagione?: XOR<PiantagioneRelationFilter, PiantagioneWhereInput>
  }, "id_annaffiatura">

  export type AnnaffiatureOrderByWithAggregationInput = {
    id_annaffiatura?: SortOrder
    id_utente?: SortOrder
    id_piantagione?: SortOrder
    giorni_rimanenti?: SortOrder
    data_save?: SortOrder
    _count?: AnnaffiatureCountOrderByAggregateInput
    _avg?: AnnaffiatureAvgOrderByAggregateInput
    _max?: AnnaffiatureMaxOrderByAggregateInput
    _min?: AnnaffiatureMinOrderByAggregateInput
    _sum?: AnnaffiatureSumOrderByAggregateInput
  }

  export type AnnaffiatureScalarWhereWithAggregatesInput = {
    AND?: AnnaffiatureScalarWhereWithAggregatesInput | AnnaffiatureScalarWhereWithAggregatesInput[]
    OR?: AnnaffiatureScalarWhereWithAggregatesInput[]
    NOT?: AnnaffiatureScalarWhereWithAggregatesInput | AnnaffiatureScalarWhereWithAggregatesInput[]
    id_annaffiatura?: IntWithAggregatesFilter<"Annaffiature"> | number
    id_utente?: IntWithAggregatesFilter<"Annaffiature"> | number
    id_piantagione?: IntWithAggregatesFilter<"Annaffiature"> | number
    giorni_rimanenti?: IntWithAggregatesFilter<"Annaffiature"> | number
    data_save?: DateTimeWithAggregatesFilter<"Annaffiature"> | Date | string
  }

  export type UtenteCreateInput = {
    nome: string
    cognome: string
    credenziali?: CredenzialiCreateNestedOneWithoutUtenteInput
    piantagioni?: PiantagioneCreateNestedManyWithoutUtenteInput
    notifiche?: NotificheCreateNestedManyWithoutUtenteInput
    annaffiature?: AnnaffiatureCreateNestedManyWithoutUtenteInput
  }

  export type UtenteUncheckedCreateInput = {
    id_utente?: number
    nome: string
    cognome: string
    credenziali?: CredenzialiUncheckedCreateNestedOneWithoutUtenteInput
    piantagioni?: PiantagioneUncheckedCreateNestedManyWithoutUtenteInput
    notifiche?: NotificheUncheckedCreateNestedManyWithoutUtenteInput
    annaffiature?: AnnaffiatureUncheckedCreateNestedManyWithoutUtenteInput
  }

  export type UtenteUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cognome?: StringFieldUpdateOperationsInput | string
    credenziali?: CredenzialiUpdateOneWithoutUtenteNestedInput
    piantagioni?: PiantagioneUpdateManyWithoutUtenteNestedInput
    notifiche?: NotificheUpdateManyWithoutUtenteNestedInput
    annaffiature?: AnnaffiatureUpdateManyWithoutUtenteNestedInput
  }

  export type UtenteUncheckedUpdateInput = {
    id_utente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cognome?: StringFieldUpdateOperationsInput | string
    credenziali?: CredenzialiUncheckedUpdateOneWithoutUtenteNestedInput
    piantagioni?: PiantagioneUncheckedUpdateManyWithoutUtenteNestedInput
    notifiche?: NotificheUncheckedUpdateManyWithoutUtenteNestedInput
    annaffiature?: AnnaffiatureUncheckedUpdateManyWithoutUtenteNestedInput
  }

  export type UtenteCreateManyInput = {
    id_utente?: number
    nome: string
    cognome: string
  }

  export type UtenteUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cognome?: StringFieldUpdateOperationsInput | string
  }

  export type UtenteUncheckedUpdateManyInput = {
    id_utente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cognome?: StringFieldUpdateOperationsInput | string
  }

  export type CredenzialiCreateInput = {
    email: string
    password: string
    utente: UtenteCreateNestedOneWithoutCredenzialiInput
  }

  export type CredenzialiUncheckedCreateInput = {
    id_utente: number
    email: string
    password: string
  }

  export type CredenzialiUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    utente?: UtenteUpdateOneRequiredWithoutCredenzialiNestedInput
  }

  export type CredenzialiUncheckedUpdateInput = {
    id_utente?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type CredenzialiCreateManyInput = {
    id_utente: number
    email: string
    password: string
  }

  export type CredenzialiUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type CredenzialiUncheckedUpdateManyInput = {
    id_utente?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type PiantagioneCreateInput = {
    nome: string
    n_slot: number
    data_inizio: Date | string
    utente: UtenteCreateNestedOneWithoutPiantagioniInput
    pianta: PiantaCreateNestedOneWithoutPiantagioniInput
    notifiche?: NotificheCreateNestedManyWithoutPiantagioneInput
    annaffiature?: AnnaffiatureCreateNestedManyWithoutPiantagioneInput
  }

  export type PiantagioneUncheckedCreateInput = {
    id_piantagione?: number
    id_utente: number
    nome: string
    n_slot: number
    data_inizio: Date | string
    id_pianta: number
    notifiche?: NotificheUncheckedCreateNestedManyWithoutPiantagioneInput
    annaffiature?: AnnaffiatureUncheckedCreateNestedManyWithoutPiantagioneInput
  }

  export type PiantagioneUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    n_slot?: IntFieldUpdateOperationsInput | number
    data_inizio?: DateTimeFieldUpdateOperationsInput | Date | string
    utente?: UtenteUpdateOneRequiredWithoutPiantagioniNestedInput
    pianta?: PiantaUpdateOneRequiredWithoutPiantagioniNestedInput
    notifiche?: NotificheUpdateManyWithoutPiantagioneNestedInput
    annaffiature?: AnnaffiatureUpdateManyWithoutPiantagioneNestedInput
  }

  export type PiantagioneUncheckedUpdateInput = {
    id_piantagione?: IntFieldUpdateOperationsInput | number
    id_utente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    n_slot?: IntFieldUpdateOperationsInput | number
    data_inizio?: DateTimeFieldUpdateOperationsInput | Date | string
    id_pianta?: IntFieldUpdateOperationsInput | number
    notifiche?: NotificheUncheckedUpdateManyWithoutPiantagioneNestedInput
    annaffiature?: AnnaffiatureUncheckedUpdateManyWithoutPiantagioneNestedInput
  }

  export type PiantagioneCreateManyInput = {
    id_piantagione?: number
    id_utente: number
    nome: string
    n_slot: number
    data_inizio: Date | string
    id_pianta: number
  }

  export type PiantagioneUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    n_slot?: IntFieldUpdateOperationsInput | number
    data_inizio?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PiantagioneUncheckedUpdateManyInput = {
    id_piantagione?: IntFieldUpdateOperationsInput | number
    id_utente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    n_slot?: IntFieldUpdateOperationsInput | number
    data_inizio?: DateTimeFieldUpdateOperationsInput | Date | string
    id_pianta?: IntFieldUpdateOperationsInput | number
  }

  export type PiantaCreateInput = {
    nome: string
    t_raccolta: number
    t_acqua: number
    piantagioni?: PiantagioneCreateNestedManyWithoutPiantaInput
  }

  export type PiantaUncheckedCreateInput = {
    id_pianta?: number
    nome: string
    t_raccolta: number
    t_acqua: number
    piantagioni?: PiantagioneUncheckedCreateNestedManyWithoutPiantaInput
  }

  export type PiantaUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    t_raccolta?: IntFieldUpdateOperationsInput | number
    t_acqua?: IntFieldUpdateOperationsInput | number
    piantagioni?: PiantagioneUpdateManyWithoutPiantaNestedInput
  }

  export type PiantaUncheckedUpdateInput = {
    id_pianta?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    t_raccolta?: IntFieldUpdateOperationsInput | number
    t_acqua?: IntFieldUpdateOperationsInput | number
    piantagioni?: PiantagioneUncheckedUpdateManyWithoutPiantaNestedInput
  }

  export type PiantaCreateManyInput = {
    id_pianta?: number
    nome: string
    t_raccolta: number
    t_acqua: number
  }

  export type PiantaUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    t_raccolta?: IntFieldUpdateOperationsInput | number
    t_acqua?: IntFieldUpdateOperationsInput | number
  }

  export type PiantaUncheckedUpdateManyInput = {
    id_pianta?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    t_raccolta?: IntFieldUpdateOperationsInput | number
    t_acqua?: IntFieldUpdateOperationsInput | number
  }

  export type NotificheCreateInput = {
    testo: string
    aperta?: boolean
    nome_piantagione: string
    data_invio: Date | string
    tipo: number
    utente: UtenteCreateNestedOneWithoutNotificheInput
    piantagione: PiantagioneCreateNestedOneWithoutNotificheInput
  }

  export type NotificheUncheckedCreateInput = {
    id_notifica?: number
    testo: string
    aperta?: boolean
    id_utente: number
    id_piantagione: number
    nome_piantagione: string
    data_invio: Date | string
    tipo: number
  }

  export type NotificheUpdateInput = {
    testo?: StringFieldUpdateOperationsInput | string
    aperta?: BoolFieldUpdateOperationsInput | boolean
    nome_piantagione?: StringFieldUpdateOperationsInput | string
    data_invio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: IntFieldUpdateOperationsInput | number
    utente?: UtenteUpdateOneRequiredWithoutNotificheNestedInput
    piantagione?: PiantagioneUpdateOneRequiredWithoutNotificheNestedInput
  }

  export type NotificheUncheckedUpdateInput = {
    id_notifica?: IntFieldUpdateOperationsInput | number
    testo?: StringFieldUpdateOperationsInput | string
    aperta?: BoolFieldUpdateOperationsInput | boolean
    id_utente?: IntFieldUpdateOperationsInput | number
    id_piantagione?: IntFieldUpdateOperationsInput | number
    nome_piantagione?: StringFieldUpdateOperationsInput | string
    data_invio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: IntFieldUpdateOperationsInput | number
  }

  export type NotificheCreateManyInput = {
    id_notifica?: number
    testo: string
    aperta?: boolean
    id_utente: number
    id_piantagione: number
    nome_piantagione: string
    data_invio: Date | string
    tipo: number
  }

  export type NotificheUpdateManyMutationInput = {
    testo?: StringFieldUpdateOperationsInput | string
    aperta?: BoolFieldUpdateOperationsInput | boolean
    nome_piantagione?: StringFieldUpdateOperationsInput | string
    data_invio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: IntFieldUpdateOperationsInput | number
  }

  export type NotificheUncheckedUpdateManyInput = {
    id_notifica?: IntFieldUpdateOperationsInput | number
    testo?: StringFieldUpdateOperationsInput | string
    aperta?: BoolFieldUpdateOperationsInput | boolean
    id_utente?: IntFieldUpdateOperationsInput | number
    id_piantagione?: IntFieldUpdateOperationsInput | number
    nome_piantagione?: StringFieldUpdateOperationsInput | string
    data_invio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: IntFieldUpdateOperationsInput | number
  }

  export type AnnaffiatureCreateInput = {
    giorni_rimanenti: number
    data_save: Date | string
    utente: UtenteCreateNestedOneWithoutAnnaffiatureInput
    piantagione: PiantagioneCreateNestedOneWithoutAnnaffiatureInput
  }

  export type AnnaffiatureUncheckedCreateInput = {
    id_annaffiatura?: number
    id_utente: number
    id_piantagione: number
    giorni_rimanenti: number
    data_save: Date | string
  }

  export type AnnaffiatureUpdateInput = {
    giorni_rimanenti?: IntFieldUpdateOperationsInput | number
    data_save?: DateTimeFieldUpdateOperationsInput | Date | string
    utente?: UtenteUpdateOneRequiredWithoutAnnaffiatureNestedInput
    piantagione?: PiantagioneUpdateOneRequiredWithoutAnnaffiatureNestedInput
  }

  export type AnnaffiatureUncheckedUpdateInput = {
    id_annaffiatura?: IntFieldUpdateOperationsInput | number
    id_utente?: IntFieldUpdateOperationsInput | number
    id_piantagione?: IntFieldUpdateOperationsInput | number
    giorni_rimanenti?: IntFieldUpdateOperationsInput | number
    data_save?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnaffiatureCreateManyInput = {
    id_annaffiatura?: number
    id_utente: number
    id_piantagione: number
    giorni_rimanenti: number
    data_save: Date | string
  }

  export type AnnaffiatureUpdateManyMutationInput = {
    giorni_rimanenti?: IntFieldUpdateOperationsInput | number
    data_save?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnaffiatureUncheckedUpdateManyInput = {
    id_annaffiatura?: IntFieldUpdateOperationsInput | number
    id_utente?: IntFieldUpdateOperationsInput | number
    id_piantagione?: IntFieldUpdateOperationsInput | number
    giorni_rimanenti?: IntFieldUpdateOperationsInput | number
    data_save?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type CredenzialiNullableRelationFilter = {
    is?: CredenzialiWhereInput | null
    isNot?: CredenzialiWhereInput | null
  }

  export type PiantagioneListRelationFilter = {
    every?: PiantagioneWhereInput
    some?: PiantagioneWhereInput
    none?: PiantagioneWhereInput
  }

  export type NotificheListRelationFilter = {
    every?: NotificheWhereInput
    some?: NotificheWhereInput
    none?: NotificheWhereInput
  }

  export type AnnaffiatureListRelationFilter = {
    every?: AnnaffiatureWhereInput
    some?: AnnaffiatureWhereInput
    none?: AnnaffiatureWhereInput
  }

  export type PiantagioneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificheOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnnaffiatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UtenteCountOrderByAggregateInput = {
    id_utente?: SortOrder
    nome?: SortOrder
    cognome?: SortOrder
  }

  export type UtenteAvgOrderByAggregateInput = {
    id_utente?: SortOrder
  }

  export type UtenteMaxOrderByAggregateInput = {
    id_utente?: SortOrder
    nome?: SortOrder
    cognome?: SortOrder
  }

  export type UtenteMinOrderByAggregateInput = {
    id_utente?: SortOrder
    nome?: SortOrder
    cognome?: SortOrder
  }

  export type UtenteSumOrderByAggregateInput = {
    id_utente?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type UtenteRelationFilter = {
    is?: UtenteWhereInput
    isNot?: UtenteWhereInput
  }

  export type CredenzialiCountOrderByAggregateInput = {
    id_utente?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type CredenzialiAvgOrderByAggregateInput = {
    id_utente?: SortOrder
  }

  export type CredenzialiMaxOrderByAggregateInput = {
    id_utente?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type CredenzialiMinOrderByAggregateInput = {
    id_utente?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type CredenzialiSumOrderByAggregateInput = {
    id_utente?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PiantaRelationFilter = {
    is?: PiantaWhereInput
    isNot?: PiantaWhereInput
  }

  export type PiantagioneCountOrderByAggregateInput = {
    id_piantagione?: SortOrder
    id_utente?: SortOrder
    nome?: SortOrder
    n_slot?: SortOrder
    data_inizio?: SortOrder
    id_pianta?: SortOrder
  }

  export type PiantagioneAvgOrderByAggregateInput = {
    id_piantagione?: SortOrder
    id_utente?: SortOrder
    n_slot?: SortOrder
    id_pianta?: SortOrder
  }

  export type PiantagioneMaxOrderByAggregateInput = {
    id_piantagione?: SortOrder
    id_utente?: SortOrder
    nome?: SortOrder
    n_slot?: SortOrder
    data_inizio?: SortOrder
    id_pianta?: SortOrder
  }

  export type PiantagioneMinOrderByAggregateInput = {
    id_piantagione?: SortOrder
    id_utente?: SortOrder
    nome?: SortOrder
    n_slot?: SortOrder
    data_inizio?: SortOrder
    id_pianta?: SortOrder
  }

  export type PiantagioneSumOrderByAggregateInput = {
    id_piantagione?: SortOrder
    id_utente?: SortOrder
    n_slot?: SortOrder
    id_pianta?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type PiantaCountOrderByAggregateInput = {
    id_pianta?: SortOrder
    nome?: SortOrder
    t_raccolta?: SortOrder
    t_acqua?: SortOrder
  }

  export type PiantaAvgOrderByAggregateInput = {
    id_pianta?: SortOrder
    t_raccolta?: SortOrder
    t_acqua?: SortOrder
  }

  export type PiantaMaxOrderByAggregateInput = {
    id_pianta?: SortOrder
    nome?: SortOrder
    t_raccolta?: SortOrder
    t_acqua?: SortOrder
  }

  export type PiantaMinOrderByAggregateInput = {
    id_pianta?: SortOrder
    nome?: SortOrder
    t_raccolta?: SortOrder
    t_acqua?: SortOrder
  }

  export type PiantaSumOrderByAggregateInput = {
    id_pianta?: SortOrder
    t_raccolta?: SortOrder
    t_acqua?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PiantagioneRelationFilter = {
    is?: PiantagioneWhereInput
    isNot?: PiantagioneWhereInput
  }

  export type NotificheCountOrderByAggregateInput = {
    id_notifica?: SortOrder
    testo?: SortOrder
    aperta?: SortOrder
    id_utente?: SortOrder
    id_piantagione?: SortOrder
    nome_piantagione?: SortOrder
    data_invio?: SortOrder
    tipo?: SortOrder
  }

  export type NotificheAvgOrderByAggregateInput = {
    id_notifica?: SortOrder
    id_utente?: SortOrder
    id_piantagione?: SortOrder
    tipo?: SortOrder
  }

  export type NotificheMaxOrderByAggregateInput = {
    id_notifica?: SortOrder
    testo?: SortOrder
    aperta?: SortOrder
    id_utente?: SortOrder
    id_piantagione?: SortOrder
    nome_piantagione?: SortOrder
    data_invio?: SortOrder
    tipo?: SortOrder
  }

  export type NotificheMinOrderByAggregateInput = {
    id_notifica?: SortOrder
    testo?: SortOrder
    aperta?: SortOrder
    id_utente?: SortOrder
    id_piantagione?: SortOrder
    nome_piantagione?: SortOrder
    data_invio?: SortOrder
    tipo?: SortOrder
  }

  export type NotificheSumOrderByAggregateInput = {
    id_notifica?: SortOrder
    id_utente?: SortOrder
    id_piantagione?: SortOrder
    tipo?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AnnaffiatureCountOrderByAggregateInput = {
    id_annaffiatura?: SortOrder
    id_utente?: SortOrder
    id_piantagione?: SortOrder
    giorni_rimanenti?: SortOrder
    data_save?: SortOrder
  }

  export type AnnaffiatureAvgOrderByAggregateInput = {
    id_annaffiatura?: SortOrder
    id_utente?: SortOrder
    id_piantagione?: SortOrder
    giorni_rimanenti?: SortOrder
  }

  export type AnnaffiatureMaxOrderByAggregateInput = {
    id_annaffiatura?: SortOrder
    id_utente?: SortOrder
    id_piantagione?: SortOrder
    giorni_rimanenti?: SortOrder
    data_save?: SortOrder
  }

  export type AnnaffiatureMinOrderByAggregateInput = {
    id_annaffiatura?: SortOrder
    id_utente?: SortOrder
    id_piantagione?: SortOrder
    giorni_rimanenti?: SortOrder
    data_save?: SortOrder
  }

  export type AnnaffiatureSumOrderByAggregateInput = {
    id_annaffiatura?: SortOrder
    id_utente?: SortOrder
    id_piantagione?: SortOrder
    giorni_rimanenti?: SortOrder
  }

  export type CredenzialiCreateNestedOneWithoutUtenteInput = {
    create?: XOR<CredenzialiCreateWithoutUtenteInput, CredenzialiUncheckedCreateWithoutUtenteInput>
    connectOrCreate?: CredenzialiCreateOrConnectWithoutUtenteInput
    connect?: CredenzialiWhereUniqueInput
  }

  export type PiantagioneCreateNestedManyWithoutUtenteInput = {
    create?: XOR<PiantagioneCreateWithoutUtenteInput, PiantagioneUncheckedCreateWithoutUtenteInput> | PiantagioneCreateWithoutUtenteInput[] | PiantagioneUncheckedCreateWithoutUtenteInput[]
    connectOrCreate?: PiantagioneCreateOrConnectWithoutUtenteInput | PiantagioneCreateOrConnectWithoutUtenteInput[]
    createMany?: PiantagioneCreateManyUtenteInputEnvelope
    connect?: PiantagioneWhereUniqueInput | PiantagioneWhereUniqueInput[]
  }

  export type NotificheCreateNestedManyWithoutUtenteInput = {
    create?: XOR<NotificheCreateWithoutUtenteInput, NotificheUncheckedCreateWithoutUtenteInput> | NotificheCreateWithoutUtenteInput[] | NotificheUncheckedCreateWithoutUtenteInput[]
    connectOrCreate?: NotificheCreateOrConnectWithoutUtenteInput | NotificheCreateOrConnectWithoutUtenteInput[]
    createMany?: NotificheCreateManyUtenteInputEnvelope
    connect?: NotificheWhereUniqueInput | NotificheWhereUniqueInput[]
  }

  export type AnnaffiatureCreateNestedManyWithoutUtenteInput = {
    create?: XOR<AnnaffiatureCreateWithoutUtenteInput, AnnaffiatureUncheckedCreateWithoutUtenteInput> | AnnaffiatureCreateWithoutUtenteInput[] | AnnaffiatureUncheckedCreateWithoutUtenteInput[]
    connectOrCreate?: AnnaffiatureCreateOrConnectWithoutUtenteInput | AnnaffiatureCreateOrConnectWithoutUtenteInput[]
    createMany?: AnnaffiatureCreateManyUtenteInputEnvelope
    connect?: AnnaffiatureWhereUniqueInput | AnnaffiatureWhereUniqueInput[]
  }

  export type CredenzialiUncheckedCreateNestedOneWithoutUtenteInput = {
    create?: XOR<CredenzialiCreateWithoutUtenteInput, CredenzialiUncheckedCreateWithoutUtenteInput>
    connectOrCreate?: CredenzialiCreateOrConnectWithoutUtenteInput
    connect?: CredenzialiWhereUniqueInput
  }

  export type PiantagioneUncheckedCreateNestedManyWithoutUtenteInput = {
    create?: XOR<PiantagioneCreateWithoutUtenteInput, PiantagioneUncheckedCreateWithoutUtenteInput> | PiantagioneCreateWithoutUtenteInput[] | PiantagioneUncheckedCreateWithoutUtenteInput[]
    connectOrCreate?: PiantagioneCreateOrConnectWithoutUtenteInput | PiantagioneCreateOrConnectWithoutUtenteInput[]
    createMany?: PiantagioneCreateManyUtenteInputEnvelope
    connect?: PiantagioneWhereUniqueInput | PiantagioneWhereUniqueInput[]
  }

  export type NotificheUncheckedCreateNestedManyWithoutUtenteInput = {
    create?: XOR<NotificheCreateWithoutUtenteInput, NotificheUncheckedCreateWithoutUtenteInput> | NotificheCreateWithoutUtenteInput[] | NotificheUncheckedCreateWithoutUtenteInput[]
    connectOrCreate?: NotificheCreateOrConnectWithoutUtenteInput | NotificheCreateOrConnectWithoutUtenteInput[]
    createMany?: NotificheCreateManyUtenteInputEnvelope
    connect?: NotificheWhereUniqueInput | NotificheWhereUniqueInput[]
  }

  export type AnnaffiatureUncheckedCreateNestedManyWithoutUtenteInput = {
    create?: XOR<AnnaffiatureCreateWithoutUtenteInput, AnnaffiatureUncheckedCreateWithoutUtenteInput> | AnnaffiatureCreateWithoutUtenteInput[] | AnnaffiatureUncheckedCreateWithoutUtenteInput[]
    connectOrCreate?: AnnaffiatureCreateOrConnectWithoutUtenteInput | AnnaffiatureCreateOrConnectWithoutUtenteInput[]
    createMany?: AnnaffiatureCreateManyUtenteInputEnvelope
    connect?: AnnaffiatureWhereUniqueInput | AnnaffiatureWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type CredenzialiUpdateOneWithoutUtenteNestedInput = {
    create?: XOR<CredenzialiCreateWithoutUtenteInput, CredenzialiUncheckedCreateWithoutUtenteInput>
    connectOrCreate?: CredenzialiCreateOrConnectWithoutUtenteInput
    upsert?: CredenzialiUpsertWithoutUtenteInput
    disconnect?: CredenzialiWhereInput | boolean
    delete?: CredenzialiWhereInput | boolean
    connect?: CredenzialiWhereUniqueInput
    update?: XOR<XOR<CredenzialiUpdateToOneWithWhereWithoutUtenteInput, CredenzialiUpdateWithoutUtenteInput>, CredenzialiUncheckedUpdateWithoutUtenteInput>
  }

  export type PiantagioneUpdateManyWithoutUtenteNestedInput = {
    create?: XOR<PiantagioneCreateWithoutUtenteInput, PiantagioneUncheckedCreateWithoutUtenteInput> | PiantagioneCreateWithoutUtenteInput[] | PiantagioneUncheckedCreateWithoutUtenteInput[]
    connectOrCreate?: PiantagioneCreateOrConnectWithoutUtenteInput | PiantagioneCreateOrConnectWithoutUtenteInput[]
    upsert?: PiantagioneUpsertWithWhereUniqueWithoutUtenteInput | PiantagioneUpsertWithWhereUniqueWithoutUtenteInput[]
    createMany?: PiantagioneCreateManyUtenteInputEnvelope
    set?: PiantagioneWhereUniqueInput | PiantagioneWhereUniqueInput[]
    disconnect?: PiantagioneWhereUniqueInput | PiantagioneWhereUniqueInput[]
    delete?: PiantagioneWhereUniqueInput | PiantagioneWhereUniqueInput[]
    connect?: PiantagioneWhereUniqueInput | PiantagioneWhereUniqueInput[]
    update?: PiantagioneUpdateWithWhereUniqueWithoutUtenteInput | PiantagioneUpdateWithWhereUniqueWithoutUtenteInput[]
    updateMany?: PiantagioneUpdateManyWithWhereWithoutUtenteInput | PiantagioneUpdateManyWithWhereWithoutUtenteInput[]
    deleteMany?: PiantagioneScalarWhereInput | PiantagioneScalarWhereInput[]
  }

  export type NotificheUpdateManyWithoutUtenteNestedInput = {
    create?: XOR<NotificheCreateWithoutUtenteInput, NotificheUncheckedCreateWithoutUtenteInput> | NotificheCreateWithoutUtenteInput[] | NotificheUncheckedCreateWithoutUtenteInput[]
    connectOrCreate?: NotificheCreateOrConnectWithoutUtenteInput | NotificheCreateOrConnectWithoutUtenteInput[]
    upsert?: NotificheUpsertWithWhereUniqueWithoutUtenteInput | NotificheUpsertWithWhereUniqueWithoutUtenteInput[]
    createMany?: NotificheCreateManyUtenteInputEnvelope
    set?: NotificheWhereUniqueInput | NotificheWhereUniqueInput[]
    disconnect?: NotificheWhereUniqueInput | NotificheWhereUniqueInput[]
    delete?: NotificheWhereUniqueInput | NotificheWhereUniqueInput[]
    connect?: NotificheWhereUniqueInput | NotificheWhereUniqueInput[]
    update?: NotificheUpdateWithWhereUniqueWithoutUtenteInput | NotificheUpdateWithWhereUniqueWithoutUtenteInput[]
    updateMany?: NotificheUpdateManyWithWhereWithoutUtenteInput | NotificheUpdateManyWithWhereWithoutUtenteInput[]
    deleteMany?: NotificheScalarWhereInput | NotificheScalarWhereInput[]
  }

  export type AnnaffiatureUpdateManyWithoutUtenteNestedInput = {
    create?: XOR<AnnaffiatureCreateWithoutUtenteInput, AnnaffiatureUncheckedCreateWithoutUtenteInput> | AnnaffiatureCreateWithoutUtenteInput[] | AnnaffiatureUncheckedCreateWithoutUtenteInput[]
    connectOrCreate?: AnnaffiatureCreateOrConnectWithoutUtenteInput | AnnaffiatureCreateOrConnectWithoutUtenteInput[]
    upsert?: AnnaffiatureUpsertWithWhereUniqueWithoutUtenteInput | AnnaffiatureUpsertWithWhereUniqueWithoutUtenteInput[]
    createMany?: AnnaffiatureCreateManyUtenteInputEnvelope
    set?: AnnaffiatureWhereUniqueInput | AnnaffiatureWhereUniqueInput[]
    disconnect?: AnnaffiatureWhereUniqueInput | AnnaffiatureWhereUniqueInput[]
    delete?: AnnaffiatureWhereUniqueInput | AnnaffiatureWhereUniqueInput[]
    connect?: AnnaffiatureWhereUniqueInput | AnnaffiatureWhereUniqueInput[]
    update?: AnnaffiatureUpdateWithWhereUniqueWithoutUtenteInput | AnnaffiatureUpdateWithWhereUniqueWithoutUtenteInput[]
    updateMany?: AnnaffiatureUpdateManyWithWhereWithoutUtenteInput | AnnaffiatureUpdateManyWithWhereWithoutUtenteInput[]
    deleteMany?: AnnaffiatureScalarWhereInput | AnnaffiatureScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CredenzialiUncheckedUpdateOneWithoutUtenteNestedInput = {
    create?: XOR<CredenzialiCreateWithoutUtenteInput, CredenzialiUncheckedCreateWithoutUtenteInput>
    connectOrCreate?: CredenzialiCreateOrConnectWithoutUtenteInput
    upsert?: CredenzialiUpsertWithoutUtenteInput
    disconnect?: CredenzialiWhereInput | boolean
    delete?: CredenzialiWhereInput | boolean
    connect?: CredenzialiWhereUniqueInput
    update?: XOR<XOR<CredenzialiUpdateToOneWithWhereWithoutUtenteInput, CredenzialiUpdateWithoutUtenteInput>, CredenzialiUncheckedUpdateWithoutUtenteInput>
  }

  export type PiantagioneUncheckedUpdateManyWithoutUtenteNestedInput = {
    create?: XOR<PiantagioneCreateWithoutUtenteInput, PiantagioneUncheckedCreateWithoutUtenteInput> | PiantagioneCreateWithoutUtenteInput[] | PiantagioneUncheckedCreateWithoutUtenteInput[]
    connectOrCreate?: PiantagioneCreateOrConnectWithoutUtenteInput | PiantagioneCreateOrConnectWithoutUtenteInput[]
    upsert?: PiantagioneUpsertWithWhereUniqueWithoutUtenteInput | PiantagioneUpsertWithWhereUniqueWithoutUtenteInput[]
    createMany?: PiantagioneCreateManyUtenteInputEnvelope
    set?: PiantagioneWhereUniqueInput | PiantagioneWhereUniqueInput[]
    disconnect?: PiantagioneWhereUniqueInput | PiantagioneWhereUniqueInput[]
    delete?: PiantagioneWhereUniqueInput | PiantagioneWhereUniqueInput[]
    connect?: PiantagioneWhereUniqueInput | PiantagioneWhereUniqueInput[]
    update?: PiantagioneUpdateWithWhereUniqueWithoutUtenteInput | PiantagioneUpdateWithWhereUniqueWithoutUtenteInput[]
    updateMany?: PiantagioneUpdateManyWithWhereWithoutUtenteInput | PiantagioneUpdateManyWithWhereWithoutUtenteInput[]
    deleteMany?: PiantagioneScalarWhereInput | PiantagioneScalarWhereInput[]
  }

  export type NotificheUncheckedUpdateManyWithoutUtenteNestedInput = {
    create?: XOR<NotificheCreateWithoutUtenteInput, NotificheUncheckedCreateWithoutUtenteInput> | NotificheCreateWithoutUtenteInput[] | NotificheUncheckedCreateWithoutUtenteInput[]
    connectOrCreate?: NotificheCreateOrConnectWithoutUtenteInput | NotificheCreateOrConnectWithoutUtenteInput[]
    upsert?: NotificheUpsertWithWhereUniqueWithoutUtenteInput | NotificheUpsertWithWhereUniqueWithoutUtenteInput[]
    createMany?: NotificheCreateManyUtenteInputEnvelope
    set?: NotificheWhereUniqueInput | NotificheWhereUniqueInput[]
    disconnect?: NotificheWhereUniqueInput | NotificheWhereUniqueInput[]
    delete?: NotificheWhereUniqueInput | NotificheWhereUniqueInput[]
    connect?: NotificheWhereUniqueInput | NotificheWhereUniqueInput[]
    update?: NotificheUpdateWithWhereUniqueWithoutUtenteInput | NotificheUpdateWithWhereUniqueWithoutUtenteInput[]
    updateMany?: NotificheUpdateManyWithWhereWithoutUtenteInput | NotificheUpdateManyWithWhereWithoutUtenteInput[]
    deleteMany?: NotificheScalarWhereInput | NotificheScalarWhereInput[]
  }

  export type AnnaffiatureUncheckedUpdateManyWithoutUtenteNestedInput = {
    create?: XOR<AnnaffiatureCreateWithoutUtenteInput, AnnaffiatureUncheckedCreateWithoutUtenteInput> | AnnaffiatureCreateWithoutUtenteInput[] | AnnaffiatureUncheckedCreateWithoutUtenteInput[]
    connectOrCreate?: AnnaffiatureCreateOrConnectWithoutUtenteInput | AnnaffiatureCreateOrConnectWithoutUtenteInput[]
    upsert?: AnnaffiatureUpsertWithWhereUniqueWithoutUtenteInput | AnnaffiatureUpsertWithWhereUniqueWithoutUtenteInput[]
    createMany?: AnnaffiatureCreateManyUtenteInputEnvelope
    set?: AnnaffiatureWhereUniqueInput | AnnaffiatureWhereUniqueInput[]
    disconnect?: AnnaffiatureWhereUniqueInput | AnnaffiatureWhereUniqueInput[]
    delete?: AnnaffiatureWhereUniqueInput | AnnaffiatureWhereUniqueInput[]
    connect?: AnnaffiatureWhereUniqueInput | AnnaffiatureWhereUniqueInput[]
    update?: AnnaffiatureUpdateWithWhereUniqueWithoutUtenteInput | AnnaffiatureUpdateWithWhereUniqueWithoutUtenteInput[]
    updateMany?: AnnaffiatureUpdateManyWithWhereWithoutUtenteInput | AnnaffiatureUpdateManyWithWhereWithoutUtenteInput[]
    deleteMany?: AnnaffiatureScalarWhereInput | AnnaffiatureScalarWhereInput[]
  }

  export type UtenteCreateNestedOneWithoutCredenzialiInput = {
    create?: XOR<UtenteCreateWithoutCredenzialiInput, UtenteUncheckedCreateWithoutCredenzialiInput>
    connectOrCreate?: UtenteCreateOrConnectWithoutCredenzialiInput
    connect?: UtenteWhereUniqueInput
  }

  export type UtenteUpdateOneRequiredWithoutCredenzialiNestedInput = {
    create?: XOR<UtenteCreateWithoutCredenzialiInput, UtenteUncheckedCreateWithoutCredenzialiInput>
    connectOrCreate?: UtenteCreateOrConnectWithoutCredenzialiInput
    upsert?: UtenteUpsertWithoutCredenzialiInput
    connect?: UtenteWhereUniqueInput
    update?: XOR<XOR<UtenteUpdateToOneWithWhereWithoutCredenzialiInput, UtenteUpdateWithoutCredenzialiInput>, UtenteUncheckedUpdateWithoutCredenzialiInput>
  }

  export type UtenteCreateNestedOneWithoutPiantagioniInput = {
    create?: XOR<UtenteCreateWithoutPiantagioniInput, UtenteUncheckedCreateWithoutPiantagioniInput>
    connectOrCreate?: UtenteCreateOrConnectWithoutPiantagioniInput
    connect?: UtenteWhereUniqueInput
  }

  export type PiantaCreateNestedOneWithoutPiantagioniInput = {
    create?: XOR<PiantaCreateWithoutPiantagioniInput, PiantaUncheckedCreateWithoutPiantagioniInput>
    connectOrCreate?: PiantaCreateOrConnectWithoutPiantagioniInput
    connect?: PiantaWhereUniqueInput
  }

  export type NotificheCreateNestedManyWithoutPiantagioneInput = {
    create?: XOR<NotificheCreateWithoutPiantagioneInput, NotificheUncheckedCreateWithoutPiantagioneInput> | NotificheCreateWithoutPiantagioneInput[] | NotificheUncheckedCreateWithoutPiantagioneInput[]
    connectOrCreate?: NotificheCreateOrConnectWithoutPiantagioneInput | NotificheCreateOrConnectWithoutPiantagioneInput[]
    createMany?: NotificheCreateManyPiantagioneInputEnvelope
    connect?: NotificheWhereUniqueInput | NotificheWhereUniqueInput[]
  }

  export type AnnaffiatureCreateNestedManyWithoutPiantagioneInput = {
    create?: XOR<AnnaffiatureCreateWithoutPiantagioneInput, AnnaffiatureUncheckedCreateWithoutPiantagioneInput> | AnnaffiatureCreateWithoutPiantagioneInput[] | AnnaffiatureUncheckedCreateWithoutPiantagioneInput[]
    connectOrCreate?: AnnaffiatureCreateOrConnectWithoutPiantagioneInput | AnnaffiatureCreateOrConnectWithoutPiantagioneInput[]
    createMany?: AnnaffiatureCreateManyPiantagioneInputEnvelope
    connect?: AnnaffiatureWhereUniqueInput | AnnaffiatureWhereUniqueInput[]
  }

  export type NotificheUncheckedCreateNestedManyWithoutPiantagioneInput = {
    create?: XOR<NotificheCreateWithoutPiantagioneInput, NotificheUncheckedCreateWithoutPiantagioneInput> | NotificheCreateWithoutPiantagioneInput[] | NotificheUncheckedCreateWithoutPiantagioneInput[]
    connectOrCreate?: NotificheCreateOrConnectWithoutPiantagioneInput | NotificheCreateOrConnectWithoutPiantagioneInput[]
    createMany?: NotificheCreateManyPiantagioneInputEnvelope
    connect?: NotificheWhereUniqueInput | NotificheWhereUniqueInput[]
  }

  export type AnnaffiatureUncheckedCreateNestedManyWithoutPiantagioneInput = {
    create?: XOR<AnnaffiatureCreateWithoutPiantagioneInput, AnnaffiatureUncheckedCreateWithoutPiantagioneInput> | AnnaffiatureCreateWithoutPiantagioneInput[] | AnnaffiatureUncheckedCreateWithoutPiantagioneInput[]
    connectOrCreate?: AnnaffiatureCreateOrConnectWithoutPiantagioneInput | AnnaffiatureCreateOrConnectWithoutPiantagioneInput[]
    createMany?: AnnaffiatureCreateManyPiantagioneInputEnvelope
    connect?: AnnaffiatureWhereUniqueInput | AnnaffiatureWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UtenteUpdateOneRequiredWithoutPiantagioniNestedInput = {
    create?: XOR<UtenteCreateWithoutPiantagioniInput, UtenteUncheckedCreateWithoutPiantagioniInput>
    connectOrCreate?: UtenteCreateOrConnectWithoutPiantagioniInput
    upsert?: UtenteUpsertWithoutPiantagioniInput
    connect?: UtenteWhereUniqueInput
    update?: XOR<XOR<UtenteUpdateToOneWithWhereWithoutPiantagioniInput, UtenteUpdateWithoutPiantagioniInput>, UtenteUncheckedUpdateWithoutPiantagioniInput>
  }

  export type PiantaUpdateOneRequiredWithoutPiantagioniNestedInput = {
    create?: XOR<PiantaCreateWithoutPiantagioniInput, PiantaUncheckedCreateWithoutPiantagioniInput>
    connectOrCreate?: PiantaCreateOrConnectWithoutPiantagioniInput
    upsert?: PiantaUpsertWithoutPiantagioniInput
    connect?: PiantaWhereUniqueInput
    update?: XOR<XOR<PiantaUpdateToOneWithWhereWithoutPiantagioniInput, PiantaUpdateWithoutPiantagioniInput>, PiantaUncheckedUpdateWithoutPiantagioniInput>
  }

  export type NotificheUpdateManyWithoutPiantagioneNestedInput = {
    create?: XOR<NotificheCreateWithoutPiantagioneInput, NotificheUncheckedCreateWithoutPiantagioneInput> | NotificheCreateWithoutPiantagioneInput[] | NotificheUncheckedCreateWithoutPiantagioneInput[]
    connectOrCreate?: NotificheCreateOrConnectWithoutPiantagioneInput | NotificheCreateOrConnectWithoutPiantagioneInput[]
    upsert?: NotificheUpsertWithWhereUniqueWithoutPiantagioneInput | NotificheUpsertWithWhereUniqueWithoutPiantagioneInput[]
    createMany?: NotificheCreateManyPiantagioneInputEnvelope
    set?: NotificheWhereUniqueInput | NotificheWhereUniqueInput[]
    disconnect?: NotificheWhereUniqueInput | NotificheWhereUniqueInput[]
    delete?: NotificheWhereUniqueInput | NotificheWhereUniqueInput[]
    connect?: NotificheWhereUniqueInput | NotificheWhereUniqueInput[]
    update?: NotificheUpdateWithWhereUniqueWithoutPiantagioneInput | NotificheUpdateWithWhereUniqueWithoutPiantagioneInput[]
    updateMany?: NotificheUpdateManyWithWhereWithoutPiantagioneInput | NotificheUpdateManyWithWhereWithoutPiantagioneInput[]
    deleteMany?: NotificheScalarWhereInput | NotificheScalarWhereInput[]
  }

  export type AnnaffiatureUpdateManyWithoutPiantagioneNestedInput = {
    create?: XOR<AnnaffiatureCreateWithoutPiantagioneInput, AnnaffiatureUncheckedCreateWithoutPiantagioneInput> | AnnaffiatureCreateWithoutPiantagioneInput[] | AnnaffiatureUncheckedCreateWithoutPiantagioneInput[]
    connectOrCreate?: AnnaffiatureCreateOrConnectWithoutPiantagioneInput | AnnaffiatureCreateOrConnectWithoutPiantagioneInput[]
    upsert?: AnnaffiatureUpsertWithWhereUniqueWithoutPiantagioneInput | AnnaffiatureUpsertWithWhereUniqueWithoutPiantagioneInput[]
    createMany?: AnnaffiatureCreateManyPiantagioneInputEnvelope
    set?: AnnaffiatureWhereUniqueInput | AnnaffiatureWhereUniqueInput[]
    disconnect?: AnnaffiatureWhereUniqueInput | AnnaffiatureWhereUniqueInput[]
    delete?: AnnaffiatureWhereUniqueInput | AnnaffiatureWhereUniqueInput[]
    connect?: AnnaffiatureWhereUniqueInput | AnnaffiatureWhereUniqueInput[]
    update?: AnnaffiatureUpdateWithWhereUniqueWithoutPiantagioneInput | AnnaffiatureUpdateWithWhereUniqueWithoutPiantagioneInput[]
    updateMany?: AnnaffiatureUpdateManyWithWhereWithoutPiantagioneInput | AnnaffiatureUpdateManyWithWhereWithoutPiantagioneInput[]
    deleteMany?: AnnaffiatureScalarWhereInput | AnnaffiatureScalarWhereInput[]
  }

  export type NotificheUncheckedUpdateManyWithoutPiantagioneNestedInput = {
    create?: XOR<NotificheCreateWithoutPiantagioneInput, NotificheUncheckedCreateWithoutPiantagioneInput> | NotificheCreateWithoutPiantagioneInput[] | NotificheUncheckedCreateWithoutPiantagioneInput[]
    connectOrCreate?: NotificheCreateOrConnectWithoutPiantagioneInput | NotificheCreateOrConnectWithoutPiantagioneInput[]
    upsert?: NotificheUpsertWithWhereUniqueWithoutPiantagioneInput | NotificheUpsertWithWhereUniqueWithoutPiantagioneInput[]
    createMany?: NotificheCreateManyPiantagioneInputEnvelope
    set?: NotificheWhereUniqueInput | NotificheWhereUniqueInput[]
    disconnect?: NotificheWhereUniqueInput | NotificheWhereUniqueInput[]
    delete?: NotificheWhereUniqueInput | NotificheWhereUniqueInput[]
    connect?: NotificheWhereUniqueInput | NotificheWhereUniqueInput[]
    update?: NotificheUpdateWithWhereUniqueWithoutPiantagioneInput | NotificheUpdateWithWhereUniqueWithoutPiantagioneInput[]
    updateMany?: NotificheUpdateManyWithWhereWithoutPiantagioneInput | NotificheUpdateManyWithWhereWithoutPiantagioneInput[]
    deleteMany?: NotificheScalarWhereInput | NotificheScalarWhereInput[]
  }

  export type AnnaffiatureUncheckedUpdateManyWithoutPiantagioneNestedInput = {
    create?: XOR<AnnaffiatureCreateWithoutPiantagioneInput, AnnaffiatureUncheckedCreateWithoutPiantagioneInput> | AnnaffiatureCreateWithoutPiantagioneInput[] | AnnaffiatureUncheckedCreateWithoutPiantagioneInput[]
    connectOrCreate?: AnnaffiatureCreateOrConnectWithoutPiantagioneInput | AnnaffiatureCreateOrConnectWithoutPiantagioneInput[]
    upsert?: AnnaffiatureUpsertWithWhereUniqueWithoutPiantagioneInput | AnnaffiatureUpsertWithWhereUniqueWithoutPiantagioneInput[]
    createMany?: AnnaffiatureCreateManyPiantagioneInputEnvelope
    set?: AnnaffiatureWhereUniqueInput | AnnaffiatureWhereUniqueInput[]
    disconnect?: AnnaffiatureWhereUniqueInput | AnnaffiatureWhereUniqueInput[]
    delete?: AnnaffiatureWhereUniqueInput | AnnaffiatureWhereUniqueInput[]
    connect?: AnnaffiatureWhereUniqueInput | AnnaffiatureWhereUniqueInput[]
    update?: AnnaffiatureUpdateWithWhereUniqueWithoutPiantagioneInput | AnnaffiatureUpdateWithWhereUniqueWithoutPiantagioneInput[]
    updateMany?: AnnaffiatureUpdateManyWithWhereWithoutPiantagioneInput | AnnaffiatureUpdateManyWithWhereWithoutPiantagioneInput[]
    deleteMany?: AnnaffiatureScalarWhereInput | AnnaffiatureScalarWhereInput[]
  }

  export type PiantagioneCreateNestedManyWithoutPiantaInput = {
    create?: XOR<PiantagioneCreateWithoutPiantaInput, PiantagioneUncheckedCreateWithoutPiantaInput> | PiantagioneCreateWithoutPiantaInput[] | PiantagioneUncheckedCreateWithoutPiantaInput[]
    connectOrCreate?: PiantagioneCreateOrConnectWithoutPiantaInput | PiantagioneCreateOrConnectWithoutPiantaInput[]
    createMany?: PiantagioneCreateManyPiantaInputEnvelope
    connect?: PiantagioneWhereUniqueInput | PiantagioneWhereUniqueInput[]
  }

  export type PiantagioneUncheckedCreateNestedManyWithoutPiantaInput = {
    create?: XOR<PiantagioneCreateWithoutPiantaInput, PiantagioneUncheckedCreateWithoutPiantaInput> | PiantagioneCreateWithoutPiantaInput[] | PiantagioneUncheckedCreateWithoutPiantaInput[]
    connectOrCreate?: PiantagioneCreateOrConnectWithoutPiantaInput | PiantagioneCreateOrConnectWithoutPiantaInput[]
    createMany?: PiantagioneCreateManyPiantaInputEnvelope
    connect?: PiantagioneWhereUniqueInput | PiantagioneWhereUniqueInput[]
  }

  export type PiantagioneUpdateManyWithoutPiantaNestedInput = {
    create?: XOR<PiantagioneCreateWithoutPiantaInput, PiantagioneUncheckedCreateWithoutPiantaInput> | PiantagioneCreateWithoutPiantaInput[] | PiantagioneUncheckedCreateWithoutPiantaInput[]
    connectOrCreate?: PiantagioneCreateOrConnectWithoutPiantaInput | PiantagioneCreateOrConnectWithoutPiantaInput[]
    upsert?: PiantagioneUpsertWithWhereUniqueWithoutPiantaInput | PiantagioneUpsertWithWhereUniqueWithoutPiantaInput[]
    createMany?: PiantagioneCreateManyPiantaInputEnvelope
    set?: PiantagioneWhereUniqueInput | PiantagioneWhereUniqueInput[]
    disconnect?: PiantagioneWhereUniqueInput | PiantagioneWhereUniqueInput[]
    delete?: PiantagioneWhereUniqueInput | PiantagioneWhereUniqueInput[]
    connect?: PiantagioneWhereUniqueInput | PiantagioneWhereUniqueInput[]
    update?: PiantagioneUpdateWithWhereUniqueWithoutPiantaInput | PiantagioneUpdateWithWhereUniqueWithoutPiantaInput[]
    updateMany?: PiantagioneUpdateManyWithWhereWithoutPiantaInput | PiantagioneUpdateManyWithWhereWithoutPiantaInput[]
    deleteMany?: PiantagioneScalarWhereInput | PiantagioneScalarWhereInput[]
  }

  export type PiantagioneUncheckedUpdateManyWithoutPiantaNestedInput = {
    create?: XOR<PiantagioneCreateWithoutPiantaInput, PiantagioneUncheckedCreateWithoutPiantaInput> | PiantagioneCreateWithoutPiantaInput[] | PiantagioneUncheckedCreateWithoutPiantaInput[]
    connectOrCreate?: PiantagioneCreateOrConnectWithoutPiantaInput | PiantagioneCreateOrConnectWithoutPiantaInput[]
    upsert?: PiantagioneUpsertWithWhereUniqueWithoutPiantaInput | PiantagioneUpsertWithWhereUniqueWithoutPiantaInput[]
    createMany?: PiantagioneCreateManyPiantaInputEnvelope
    set?: PiantagioneWhereUniqueInput | PiantagioneWhereUniqueInput[]
    disconnect?: PiantagioneWhereUniqueInput | PiantagioneWhereUniqueInput[]
    delete?: PiantagioneWhereUniqueInput | PiantagioneWhereUniqueInput[]
    connect?: PiantagioneWhereUniqueInput | PiantagioneWhereUniqueInput[]
    update?: PiantagioneUpdateWithWhereUniqueWithoutPiantaInput | PiantagioneUpdateWithWhereUniqueWithoutPiantaInput[]
    updateMany?: PiantagioneUpdateManyWithWhereWithoutPiantaInput | PiantagioneUpdateManyWithWhereWithoutPiantaInput[]
    deleteMany?: PiantagioneScalarWhereInput | PiantagioneScalarWhereInput[]
  }

  export type UtenteCreateNestedOneWithoutNotificheInput = {
    create?: XOR<UtenteCreateWithoutNotificheInput, UtenteUncheckedCreateWithoutNotificheInput>
    connectOrCreate?: UtenteCreateOrConnectWithoutNotificheInput
    connect?: UtenteWhereUniqueInput
  }

  export type PiantagioneCreateNestedOneWithoutNotificheInput = {
    create?: XOR<PiantagioneCreateWithoutNotificheInput, PiantagioneUncheckedCreateWithoutNotificheInput>
    connectOrCreate?: PiantagioneCreateOrConnectWithoutNotificheInput
    connect?: PiantagioneWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UtenteUpdateOneRequiredWithoutNotificheNestedInput = {
    create?: XOR<UtenteCreateWithoutNotificheInput, UtenteUncheckedCreateWithoutNotificheInput>
    connectOrCreate?: UtenteCreateOrConnectWithoutNotificheInput
    upsert?: UtenteUpsertWithoutNotificheInput
    connect?: UtenteWhereUniqueInput
    update?: XOR<XOR<UtenteUpdateToOneWithWhereWithoutNotificheInput, UtenteUpdateWithoutNotificheInput>, UtenteUncheckedUpdateWithoutNotificheInput>
  }

  export type PiantagioneUpdateOneRequiredWithoutNotificheNestedInput = {
    create?: XOR<PiantagioneCreateWithoutNotificheInput, PiantagioneUncheckedCreateWithoutNotificheInput>
    connectOrCreate?: PiantagioneCreateOrConnectWithoutNotificheInput
    upsert?: PiantagioneUpsertWithoutNotificheInput
    connect?: PiantagioneWhereUniqueInput
    update?: XOR<XOR<PiantagioneUpdateToOneWithWhereWithoutNotificheInput, PiantagioneUpdateWithoutNotificheInput>, PiantagioneUncheckedUpdateWithoutNotificheInput>
  }

  export type UtenteCreateNestedOneWithoutAnnaffiatureInput = {
    create?: XOR<UtenteCreateWithoutAnnaffiatureInput, UtenteUncheckedCreateWithoutAnnaffiatureInput>
    connectOrCreate?: UtenteCreateOrConnectWithoutAnnaffiatureInput
    connect?: UtenteWhereUniqueInput
  }

  export type PiantagioneCreateNestedOneWithoutAnnaffiatureInput = {
    create?: XOR<PiantagioneCreateWithoutAnnaffiatureInput, PiantagioneUncheckedCreateWithoutAnnaffiatureInput>
    connectOrCreate?: PiantagioneCreateOrConnectWithoutAnnaffiatureInput
    connect?: PiantagioneWhereUniqueInput
  }

  export type UtenteUpdateOneRequiredWithoutAnnaffiatureNestedInput = {
    create?: XOR<UtenteCreateWithoutAnnaffiatureInput, UtenteUncheckedCreateWithoutAnnaffiatureInput>
    connectOrCreate?: UtenteCreateOrConnectWithoutAnnaffiatureInput
    upsert?: UtenteUpsertWithoutAnnaffiatureInput
    connect?: UtenteWhereUniqueInput
    update?: XOR<XOR<UtenteUpdateToOneWithWhereWithoutAnnaffiatureInput, UtenteUpdateWithoutAnnaffiatureInput>, UtenteUncheckedUpdateWithoutAnnaffiatureInput>
  }

  export type PiantagioneUpdateOneRequiredWithoutAnnaffiatureNestedInput = {
    create?: XOR<PiantagioneCreateWithoutAnnaffiatureInput, PiantagioneUncheckedCreateWithoutAnnaffiatureInput>
    connectOrCreate?: PiantagioneCreateOrConnectWithoutAnnaffiatureInput
    upsert?: PiantagioneUpsertWithoutAnnaffiatureInput
    connect?: PiantagioneWhereUniqueInput
    update?: XOR<XOR<PiantagioneUpdateToOneWithWhereWithoutAnnaffiatureInput, PiantagioneUpdateWithoutAnnaffiatureInput>, PiantagioneUncheckedUpdateWithoutAnnaffiatureInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CredenzialiCreateWithoutUtenteInput = {
    email: string
    password: string
  }

  export type CredenzialiUncheckedCreateWithoutUtenteInput = {
    email: string
    password: string
  }

  export type CredenzialiCreateOrConnectWithoutUtenteInput = {
    where: CredenzialiWhereUniqueInput
    create: XOR<CredenzialiCreateWithoutUtenteInput, CredenzialiUncheckedCreateWithoutUtenteInput>
  }

  export type PiantagioneCreateWithoutUtenteInput = {
    nome: string
    n_slot: number
    data_inizio: Date | string
    pianta: PiantaCreateNestedOneWithoutPiantagioniInput
    notifiche?: NotificheCreateNestedManyWithoutPiantagioneInput
    annaffiature?: AnnaffiatureCreateNestedManyWithoutPiantagioneInput
  }

  export type PiantagioneUncheckedCreateWithoutUtenteInput = {
    id_piantagione?: number
    nome: string
    n_slot: number
    data_inizio: Date | string
    id_pianta: number
    notifiche?: NotificheUncheckedCreateNestedManyWithoutPiantagioneInput
    annaffiature?: AnnaffiatureUncheckedCreateNestedManyWithoutPiantagioneInput
  }

  export type PiantagioneCreateOrConnectWithoutUtenteInput = {
    where: PiantagioneWhereUniqueInput
    create: XOR<PiantagioneCreateWithoutUtenteInput, PiantagioneUncheckedCreateWithoutUtenteInput>
  }

  export type PiantagioneCreateManyUtenteInputEnvelope = {
    data: PiantagioneCreateManyUtenteInput | PiantagioneCreateManyUtenteInput[]
    skipDuplicates?: boolean
  }

  export type NotificheCreateWithoutUtenteInput = {
    testo: string
    aperta?: boolean
    nome_piantagione: string
    data_invio: Date | string
    tipo: number
    piantagione: PiantagioneCreateNestedOneWithoutNotificheInput
  }

  export type NotificheUncheckedCreateWithoutUtenteInput = {
    id_notifica?: number
    testo: string
    aperta?: boolean
    id_piantagione: number
    nome_piantagione: string
    data_invio: Date | string
    tipo: number
  }

  export type NotificheCreateOrConnectWithoutUtenteInput = {
    where: NotificheWhereUniqueInput
    create: XOR<NotificheCreateWithoutUtenteInput, NotificheUncheckedCreateWithoutUtenteInput>
  }

  export type NotificheCreateManyUtenteInputEnvelope = {
    data: NotificheCreateManyUtenteInput | NotificheCreateManyUtenteInput[]
    skipDuplicates?: boolean
  }

  export type AnnaffiatureCreateWithoutUtenteInput = {
    giorni_rimanenti: number
    data_save: Date | string
    piantagione: PiantagioneCreateNestedOneWithoutAnnaffiatureInput
  }

  export type AnnaffiatureUncheckedCreateWithoutUtenteInput = {
    id_annaffiatura?: number
    id_piantagione: number
    giorni_rimanenti: number
    data_save: Date | string
  }

  export type AnnaffiatureCreateOrConnectWithoutUtenteInput = {
    where: AnnaffiatureWhereUniqueInput
    create: XOR<AnnaffiatureCreateWithoutUtenteInput, AnnaffiatureUncheckedCreateWithoutUtenteInput>
  }

  export type AnnaffiatureCreateManyUtenteInputEnvelope = {
    data: AnnaffiatureCreateManyUtenteInput | AnnaffiatureCreateManyUtenteInput[]
    skipDuplicates?: boolean
  }

  export type CredenzialiUpsertWithoutUtenteInput = {
    update: XOR<CredenzialiUpdateWithoutUtenteInput, CredenzialiUncheckedUpdateWithoutUtenteInput>
    create: XOR<CredenzialiCreateWithoutUtenteInput, CredenzialiUncheckedCreateWithoutUtenteInput>
    where?: CredenzialiWhereInput
  }

  export type CredenzialiUpdateToOneWithWhereWithoutUtenteInput = {
    where?: CredenzialiWhereInput
    data: XOR<CredenzialiUpdateWithoutUtenteInput, CredenzialiUncheckedUpdateWithoutUtenteInput>
  }

  export type CredenzialiUpdateWithoutUtenteInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type CredenzialiUncheckedUpdateWithoutUtenteInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type PiantagioneUpsertWithWhereUniqueWithoutUtenteInput = {
    where: PiantagioneWhereUniqueInput
    update: XOR<PiantagioneUpdateWithoutUtenteInput, PiantagioneUncheckedUpdateWithoutUtenteInput>
    create: XOR<PiantagioneCreateWithoutUtenteInput, PiantagioneUncheckedCreateWithoutUtenteInput>
  }

  export type PiantagioneUpdateWithWhereUniqueWithoutUtenteInput = {
    where: PiantagioneWhereUniqueInput
    data: XOR<PiantagioneUpdateWithoutUtenteInput, PiantagioneUncheckedUpdateWithoutUtenteInput>
  }

  export type PiantagioneUpdateManyWithWhereWithoutUtenteInput = {
    where: PiantagioneScalarWhereInput
    data: XOR<PiantagioneUpdateManyMutationInput, PiantagioneUncheckedUpdateManyWithoutUtenteInput>
  }

  export type PiantagioneScalarWhereInput = {
    AND?: PiantagioneScalarWhereInput | PiantagioneScalarWhereInput[]
    OR?: PiantagioneScalarWhereInput[]
    NOT?: PiantagioneScalarWhereInput | PiantagioneScalarWhereInput[]
    id_piantagione?: IntFilter<"Piantagione"> | number
    id_utente?: IntFilter<"Piantagione"> | number
    nome?: StringFilter<"Piantagione"> | string
    n_slot?: IntFilter<"Piantagione"> | number
    data_inizio?: DateTimeFilter<"Piantagione"> | Date | string
    id_pianta?: IntFilter<"Piantagione"> | number
  }

  export type NotificheUpsertWithWhereUniqueWithoutUtenteInput = {
    where: NotificheWhereUniqueInput
    update: XOR<NotificheUpdateWithoutUtenteInput, NotificheUncheckedUpdateWithoutUtenteInput>
    create: XOR<NotificheCreateWithoutUtenteInput, NotificheUncheckedCreateWithoutUtenteInput>
  }

  export type NotificheUpdateWithWhereUniqueWithoutUtenteInput = {
    where: NotificheWhereUniqueInput
    data: XOR<NotificheUpdateWithoutUtenteInput, NotificheUncheckedUpdateWithoutUtenteInput>
  }

  export type NotificheUpdateManyWithWhereWithoutUtenteInput = {
    where: NotificheScalarWhereInput
    data: XOR<NotificheUpdateManyMutationInput, NotificheUncheckedUpdateManyWithoutUtenteInput>
  }

  export type NotificheScalarWhereInput = {
    AND?: NotificheScalarWhereInput | NotificheScalarWhereInput[]
    OR?: NotificheScalarWhereInput[]
    NOT?: NotificheScalarWhereInput | NotificheScalarWhereInput[]
    id_notifica?: IntFilter<"Notifiche"> | number
    testo?: StringFilter<"Notifiche"> | string
    aperta?: BoolFilter<"Notifiche"> | boolean
    id_utente?: IntFilter<"Notifiche"> | number
    id_piantagione?: IntFilter<"Notifiche"> | number
    nome_piantagione?: StringFilter<"Notifiche"> | string
    data_invio?: DateTimeFilter<"Notifiche"> | Date | string
    tipo?: IntFilter<"Notifiche"> | number
  }

  export type AnnaffiatureUpsertWithWhereUniqueWithoutUtenteInput = {
    where: AnnaffiatureWhereUniqueInput
    update: XOR<AnnaffiatureUpdateWithoutUtenteInput, AnnaffiatureUncheckedUpdateWithoutUtenteInput>
    create: XOR<AnnaffiatureCreateWithoutUtenteInput, AnnaffiatureUncheckedCreateWithoutUtenteInput>
  }

  export type AnnaffiatureUpdateWithWhereUniqueWithoutUtenteInput = {
    where: AnnaffiatureWhereUniqueInput
    data: XOR<AnnaffiatureUpdateWithoutUtenteInput, AnnaffiatureUncheckedUpdateWithoutUtenteInput>
  }

  export type AnnaffiatureUpdateManyWithWhereWithoutUtenteInput = {
    where: AnnaffiatureScalarWhereInput
    data: XOR<AnnaffiatureUpdateManyMutationInput, AnnaffiatureUncheckedUpdateManyWithoutUtenteInput>
  }

  export type AnnaffiatureScalarWhereInput = {
    AND?: AnnaffiatureScalarWhereInput | AnnaffiatureScalarWhereInput[]
    OR?: AnnaffiatureScalarWhereInput[]
    NOT?: AnnaffiatureScalarWhereInput | AnnaffiatureScalarWhereInput[]
    id_annaffiatura?: IntFilter<"Annaffiature"> | number
    id_utente?: IntFilter<"Annaffiature"> | number
    id_piantagione?: IntFilter<"Annaffiature"> | number
    giorni_rimanenti?: IntFilter<"Annaffiature"> | number
    data_save?: DateTimeFilter<"Annaffiature"> | Date | string
  }

  export type UtenteCreateWithoutCredenzialiInput = {
    nome: string
    cognome: string
    piantagioni?: PiantagioneCreateNestedManyWithoutUtenteInput
    notifiche?: NotificheCreateNestedManyWithoutUtenteInput
    annaffiature?: AnnaffiatureCreateNestedManyWithoutUtenteInput
  }

  export type UtenteUncheckedCreateWithoutCredenzialiInput = {
    id_utente?: number
    nome: string
    cognome: string
    piantagioni?: PiantagioneUncheckedCreateNestedManyWithoutUtenteInput
    notifiche?: NotificheUncheckedCreateNestedManyWithoutUtenteInput
    annaffiature?: AnnaffiatureUncheckedCreateNestedManyWithoutUtenteInput
  }

  export type UtenteCreateOrConnectWithoutCredenzialiInput = {
    where: UtenteWhereUniqueInput
    create: XOR<UtenteCreateWithoutCredenzialiInput, UtenteUncheckedCreateWithoutCredenzialiInput>
  }

  export type UtenteUpsertWithoutCredenzialiInput = {
    update: XOR<UtenteUpdateWithoutCredenzialiInput, UtenteUncheckedUpdateWithoutCredenzialiInput>
    create: XOR<UtenteCreateWithoutCredenzialiInput, UtenteUncheckedCreateWithoutCredenzialiInput>
    where?: UtenteWhereInput
  }

  export type UtenteUpdateToOneWithWhereWithoutCredenzialiInput = {
    where?: UtenteWhereInput
    data: XOR<UtenteUpdateWithoutCredenzialiInput, UtenteUncheckedUpdateWithoutCredenzialiInput>
  }

  export type UtenteUpdateWithoutCredenzialiInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cognome?: StringFieldUpdateOperationsInput | string
    piantagioni?: PiantagioneUpdateManyWithoutUtenteNestedInput
    notifiche?: NotificheUpdateManyWithoutUtenteNestedInput
    annaffiature?: AnnaffiatureUpdateManyWithoutUtenteNestedInput
  }

  export type UtenteUncheckedUpdateWithoutCredenzialiInput = {
    id_utente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cognome?: StringFieldUpdateOperationsInput | string
    piantagioni?: PiantagioneUncheckedUpdateManyWithoutUtenteNestedInput
    notifiche?: NotificheUncheckedUpdateManyWithoutUtenteNestedInput
    annaffiature?: AnnaffiatureUncheckedUpdateManyWithoutUtenteNestedInput
  }

  export type UtenteCreateWithoutPiantagioniInput = {
    nome: string
    cognome: string
    credenziali?: CredenzialiCreateNestedOneWithoutUtenteInput
    notifiche?: NotificheCreateNestedManyWithoutUtenteInput
    annaffiature?: AnnaffiatureCreateNestedManyWithoutUtenteInput
  }

  export type UtenteUncheckedCreateWithoutPiantagioniInput = {
    id_utente?: number
    nome: string
    cognome: string
    credenziali?: CredenzialiUncheckedCreateNestedOneWithoutUtenteInput
    notifiche?: NotificheUncheckedCreateNestedManyWithoutUtenteInput
    annaffiature?: AnnaffiatureUncheckedCreateNestedManyWithoutUtenteInput
  }

  export type UtenteCreateOrConnectWithoutPiantagioniInput = {
    where: UtenteWhereUniqueInput
    create: XOR<UtenteCreateWithoutPiantagioniInput, UtenteUncheckedCreateWithoutPiantagioniInput>
  }

  export type PiantaCreateWithoutPiantagioniInput = {
    nome: string
    t_raccolta: number
    t_acqua: number
  }

  export type PiantaUncheckedCreateWithoutPiantagioniInput = {
    id_pianta?: number
    nome: string
    t_raccolta: number
    t_acqua: number
  }

  export type PiantaCreateOrConnectWithoutPiantagioniInput = {
    where: PiantaWhereUniqueInput
    create: XOR<PiantaCreateWithoutPiantagioniInput, PiantaUncheckedCreateWithoutPiantagioniInput>
  }

  export type NotificheCreateWithoutPiantagioneInput = {
    testo: string
    aperta?: boolean
    nome_piantagione: string
    data_invio: Date | string
    tipo: number
    utente: UtenteCreateNestedOneWithoutNotificheInput
  }

  export type NotificheUncheckedCreateWithoutPiantagioneInput = {
    id_notifica?: number
    testo: string
    aperta?: boolean
    id_utente: number
    nome_piantagione: string
    data_invio: Date | string
    tipo: number
  }

  export type NotificheCreateOrConnectWithoutPiantagioneInput = {
    where: NotificheWhereUniqueInput
    create: XOR<NotificheCreateWithoutPiantagioneInput, NotificheUncheckedCreateWithoutPiantagioneInput>
  }

  export type NotificheCreateManyPiantagioneInputEnvelope = {
    data: NotificheCreateManyPiantagioneInput | NotificheCreateManyPiantagioneInput[]
    skipDuplicates?: boolean
  }

  export type AnnaffiatureCreateWithoutPiantagioneInput = {
    giorni_rimanenti: number
    data_save: Date | string
    utente: UtenteCreateNestedOneWithoutAnnaffiatureInput
  }

  export type AnnaffiatureUncheckedCreateWithoutPiantagioneInput = {
    id_annaffiatura?: number
    id_utente: number
    giorni_rimanenti: number
    data_save: Date | string
  }

  export type AnnaffiatureCreateOrConnectWithoutPiantagioneInput = {
    where: AnnaffiatureWhereUniqueInput
    create: XOR<AnnaffiatureCreateWithoutPiantagioneInput, AnnaffiatureUncheckedCreateWithoutPiantagioneInput>
  }

  export type AnnaffiatureCreateManyPiantagioneInputEnvelope = {
    data: AnnaffiatureCreateManyPiantagioneInput | AnnaffiatureCreateManyPiantagioneInput[]
    skipDuplicates?: boolean
  }

  export type UtenteUpsertWithoutPiantagioniInput = {
    update: XOR<UtenteUpdateWithoutPiantagioniInput, UtenteUncheckedUpdateWithoutPiantagioniInput>
    create: XOR<UtenteCreateWithoutPiantagioniInput, UtenteUncheckedCreateWithoutPiantagioniInput>
    where?: UtenteWhereInput
  }

  export type UtenteUpdateToOneWithWhereWithoutPiantagioniInput = {
    where?: UtenteWhereInput
    data: XOR<UtenteUpdateWithoutPiantagioniInput, UtenteUncheckedUpdateWithoutPiantagioniInput>
  }

  export type UtenteUpdateWithoutPiantagioniInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cognome?: StringFieldUpdateOperationsInput | string
    credenziali?: CredenzialiUpdateOneWithoutUtenteNestedInput
    notifiche?: NotificheUpdateManyWithoutUtenteNestedInput
    annaffiature?: AnnaffiatureUpdateManyWithoutUtenteNestedInput
  }

  export type UtenteUncheckedUpdateWithoutPiantagioniInput = {
    id_utente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cognome?: StringFieldUpdateOperationsInput | string
    credenziali?: CredenzialiUncheckedUpdateOneWithoutUtenteNestedInput
    notifiche?: NotificheUncheckedUpdateManyWithoutUtenteNestedInput
    annaffiature?: AnnaffiatureUncheckedUpdateManyWithoutUtenteNestedInput
  }

  export type PiantaUpsertWithoutPiantagioniInput = {
    update: XOR<PiantaUpdateWithoutPiantagioniInput, PiantaUncheckedUpdateWithoutPiantagioniInput>
    create: XOR<PiantaCreateWithoutPiantagioniInput, PiantaUncheckedCreateWithoutPiantagioniInput>
    where?: PiantaWhereInput
  }

  export type PiantaUpdateToOneWithWhereWithoutPiantagioniInput = {
    where?: PiantaWhereInput
    data: XOR<PiantaUpdateWithoutPiantagioniInput, PiantaUncheckedUpdateWithoutPiantagioniInput>
  }

  export type PiantaUpdateWithoutPiantagioniInput = {
    nome?: StringFieldUpdateOperationsInput | string
    t_raccolta?: IntFieldUpdateOperationsInput | number
    t_acqua?: IntFieldUpdateOperationsInput | number
  }

  export type PiantaUncheckedUpdateWithoutPiantagioniInput = {
    id_pianta?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    t_raccolta?: IntFieldUpdateOperationsInput | number
    t_acqua?: IntFieldUpdateOperationsInput | number
  }

  export type NotificheUpsertWithWhereUniqueWithoutPiantagioneInput = {
    where: NotificheWhereUniqueInput
    update: XOR<NotificheUpdateWithoutPiantagioneInput, NotificheUncheckedUpdateWithoutPiantagioneInput>
    create: XOR<NotificheCreateWithoutPiantagioneInput, NotificheUncheckedCreateWithoutPiantagioneInput>
  }

  export type NotificheUpdateWithWhereUniqueWithoutPiantagioneInput = {
    where: NotificheWhereUniqueInput
    data: XOR<NotificheUpdateWithoutPiantagioneInput, NotificheUncheckedUpdateWithoutPiantagioneInput>
  }

  export type NotificheUpdateManyWithWhereWithoutPiantagioneInput = {
    where: NotificheScalarWhereInput
    data: XOR<NotificheUpdateManyMutationInput, NotificheUncheckedUpdateManyWithoutPiantagioneInput>
  }

  export type AnnaffiatureUpsertWithWhereUniqueWithoutPiantagioneInput = {
    where: AnnaffiatureWhereUniqueInput
    update: XOR<AnnaffiatureUpdateWithoutPiantagioneInput, AnnaffiatureUncheckedUpdateWithoutPiantagioneInput>
    create: XOR<AnnaffiatureCreateWithoutPiantagioneInput, AnnaffiatureUncheckedCreateWithoutPiantagioneInput>
  }

  export type AnnaffiatureUpdateWithWhereUniqueWithoutPiantagioneInput = {
    where: AnnaffiatureWhereUniqueInput
    data: XOR<AnnaffiatureUpdateWithoutPiantagioneInput, AnnaffiatureUncheckedUpdateWithoutPiantagioneInput>
  }

  export type AnnaffiatureUpdateManyWithWhereWithoutPiantagioneInput = {
    where: AnnaffiatureScalarWhereInput
    data: XOR<AnnaffiatureUpdateManyMutationInput, AnnaffiatureUncheckedUpdateManyWithoutPiantagioneInput>
  }

  export type PiantagioneCreateWithoutPiantaInput = {
    nome: string
    n_slot: number
    data_inizio: Date | string
    utente: UtenteCreateNestedOneWithoutPiantagioniInput
    notifiche?: NotificheCreateNestedManyWithoutPiantagioneInput
    annaffiature?: AnnaffiatureCreateNestedManyWithoutPiantagioneInput
  }

  export type PiantagioneUncheckedCreateWithoutPiantaInput = {
    id_piantagione?: number
    id_utente: number
    nome: string
    n_slot: number
    data_inizio: Date | string
    notifiche?: NotificheUncheckedCreateNestedManyWithoutPiantagioneInput
    annaffiature?: AnnaffiatureUncheckedCreateNestedManyWithoutPiantagioneInput
  }

  export type PiantagioneCreateOrConnectWithoutPiantaInput = {
    where: PiantagioneWhereUniqueInput
    create: XOR<PiantagioneCreateWithoutPiantaInput, PiantagioneUncheckedCreateWithoutPiantaInput>
  }

  export type PiantagioneCreateManyPiantaInputEnvelope = {
    data: PiantagioneCreateManyPiantaInput | PiantagioneCreateManyPiantaInput[]
    skipDuplicates?: boolean
  }

  export type PiantagioneUpsertWithWhereUniqueWithoutPiantaInput = {
    where: PiantagioneWhereUniqueInput
    update: XOR<PiantagioneUpdateWithoutPiantaInput, PiantagioneUncheckedUpdateWithoutPiantaInput>
    create: XOR<PiantagioneCreateWithoutPiantaInput, PiantagioneUncheckedCreateWithoutPiantaInput>
  }

  export type PiantagioneUpdateWithWhereUniqueWithoutPiantaInput = {
    where: PiantagioneWhereUniqueInput
    data: XOR<PiantagioneUpdateWithoutPiantaInput, PiantagioneUncheckedUpdateWithoutPiantaInput>
  }

  export type PiantagioneUpdateManyWithWhereWithoutPiantaInput = {
    where: PiantagioneScalarWhereInput
    data: XOR<PiantagioneUpdateManyMutationInput, PiantagioneUncheckedUpdateManyWithoutPiantaInput>
  }

  export type UtenteCreateWithoutNotificheInput = {
    nome: string
    cognome: string
    credenziali?: CredenzialiCreateNestedOneWithoutUtenteInput
    piantagioni?: PiantagioneCreateNestedManyWithoutUtenteInput
    annaffiature?: AnnaffiatureCreateNestedManyWithoutUtenteInput
  }

  export type UtenteUncheckedCreateWithoutNotificheInput = {
    id_utente?: number
    nome: string
    cognome: string
    credenziali?: CredenzialiUncheckedCreateNestedOneWithoutUtenteInput
    piantagioni?: PiantagioneUncheckedCreateNestedManyWithoutUtenteInput
    annaffiature?: AnnaffiatureUncheckedCreateNestedManyWithoutUtenteInput
  }

  export type UtenteCreateOrConnectWithoutNotificheInput = {
    where: UtenteWhereUniqueInput
    create: XOR<UtenteCreateWithoutNotificheInput, UtenteUncheckedCreateWithoutNotificheInput>
  }

  export type PiantagioneCreateWithoutNotificheInput = {
    nome: string
    n_slot: number
    data_inizio: Date | string
    utente: UtenteCreateNestedOneWithoutPiantagioniInput
    pianta: PiantaCreateNestedOneWithoutPiantagioniInput
    annaffiature?: AnnaffiatureCreateNestedManyWithoutPiantagioneInput
  }

  export type PiantagioneUncheckedCreateWithoutNotificheInput = {
    id_piantagione?: number
    id_utente: number
    nome: string
    n_slot: number
    data_inizio: Date | string
    id_pianta: number
    annaffiature?: AnnaffiatureUncheckedCreateNestedManyWithoutPiantagioneInput
  }

  export type PiantagioneCreateOrConnectWithoutNotificheInput = {
    where: PiantagioneWhereUniqueInput
    create: XOR<PiantagioneCreateWithoutNotificheInput, PiantagioneUncheckedCreateWithoutNotificheInput>
  }

  export type UtenteUpsertWithoutNotificheInput = {
    update: XOR<UtenteUpdateWithoutNotificheInput, UtenteUncheckedUpdateWithoutNotificheInput>
    create: XOR<UtenteCreateWithoutNotificheInput, UtenteUncheckedCreateWithoutNotificheInput>
    where?: UtenteWhereInput
  }

  export type UtenteUpdateToOneWithWhereWithoutNotificheInput = {
    where?: UtenteWhereInput
    data: XOR<UtenteUpdateWithoutNotificheInput, UtenteUncheckedUpdateWithoutNotificheInput>
  }

  export type UtenteUpdateWithoutNotificheInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cognome?: StringFieldUpdateOperationsInput | string
    credenziali?: CredenzialiUpdateOneWithoutUtenteNestedInput
    piantagioni?: PiantagioneUpdateManyWithoutUtenteNestedInput
    annaffiature?: AnnaffiatureUpdateManyWithoutUtenteNestedInput
  }

  export type UtenteUncheckedUpdateWithoutNotificheInput = {
    id_utente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cognome?: StringFieldUpdateOperationsInput | string
    credenziali?: CredenzialiUncheckedUpdateOneWithoutUtenteNestedInput
    piantagioni?: PiantagioneUncheckedUpdateManyWithoutUtenteNestedInput
    annaffiature?: AnnaffiatureUncheckedUpdateManyWithoutUtenteNestedInput
  }

  export type PiantagioneUpsertWithoutNotificheInput = {
    update: XOR<PiantagioneUpdateWithoutNotificheInput, PiantagioneUncheckedUpdateWithoutNotificheInput>
    create: XOR<PiantagioneCreateWithoutNotificheInput, PiantagioneUncheckedCreateWithoutNotificheInput>
    where?: PiantagioneWhereInput
  }

  export type PiantagioneUpdateToOneWithWhereWithoutNotificheInput = {
    where?: PiantagioneWhereInput
    data: XOR<PiantagioneUpdateWithoutNotificheInput, PiantagioneUncheckedUpdateWithoutNotificheInput>
  }

  export type PiantagioneUpdateWithoutNotificheInput = {
    nome?: StringFieldUpdateOperationsInput | string
    n_slot?: IntFieldUpdateOperationsInput | number
    data_inizio?: DateTimeFieldUpdateOperationsInput | Date | string
    utente?: UtenteUpdateOneRequiredWithoutPiantagioniNestedInput
    pianta?: PiantaUpdateOneRequiredWithoutPiantagioniNestedInput
    annaffiature?: AnnaffiatureUpdateManyWithoutPiantagioneNestedInput
  }

  export type PiantagioneUncheckedUpdateWithoutNotificheInput = {
    id_piantagione?: IntFieldUpdateOperationsInput | number
    id_utente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    n_slot?: IntFieldUpdateOperationsInput | number
    data_inizio?: DateTimeFieldUpdateOperationsInput | Date | string
    id_pianta?: IntFieldUpdateOperationsInput | number
    annaffiature?: AnnaffiatureUncheckedUpdateManyWithoutPiantagioneNestedInput
  }

  export type UtenteCreateWithoutAnnaffiatureInput = {
    nome: string
    cognome: string
    credenziali?: CredenzialiCreateNestedOneWithoutUtenteInput
    piantagioni?: PiantagioneCreateNestedManyWithoutUtenteInput
    notifiche?: NotificheCreateNestedManyWithoutUtenteInput
  }

  export type UtenteUncheckedCreateWithoutAnnaffiatureInput = {
    id_utente?: number
    nome: string
    cognome: string
    credenziali?: CredenzialiUncheckedCreateNestedOneWithoutUtenteInput
    piantagioni?: PiantagioneUncheckedCreateNestedManyWithoutUtenteInput
    notifiche?: NotificheUncheckedCreateNestedManyWithoutUtenteInput
  }

  export type UtenteCreateOrConnectWithoutAnnaffiatureInput = {
    where: UtenteWhereUniqueInput
    create: XOR<UtenteCreateWithoutAnnaffiatureInput, UtenteUncheckedCreateWithoutAnnaffiatureInput>
  }

  export type PiantagioneCreateWithoutAnnaffiatureInput = {
    nome: string
    n_slot: number
    data_inizio: Date | string
    utente: UtenteCreateNestedOneWithoutPiantagioniInput
    pianta: PiantaCreateNestedOneWithoutPiantagioniInput
    notifiche?: NotificheCreateNestedManyWithoutPiantagioneInput
  }

  export type PiantagioneUncheckedCreateWithoutAnnaffiatureInput = {
    id_piantagione?: number
    id_utente: number
    nome: string
    n_slot: number
    data_inizio: Date | string
    id_pianta: number
    notifiche?: NotificheUncheckedCreateNestedManyWithoutPiantagioneInput
  }

  export type PiantagioneCreateOrConnectWithoutAnnaffiatureInput = {
    where: PiantagioneWhereUniqueInput
    create: XOR<PiantagioneCreateWithoutAnnaffiatureInput, PiantagioneUncheckedCreateWithoutAnnaffiatureInput>
  }

  export type UtenteUpsertWithoutAnnaffiatureInput = {
    update: XOR<UtenteUpdateWithoutAnnaffiatureInput, UtenteUncheckedUpdateWithoutAnnaffiatureInput>
    create: XOR<UtenteCreateWithoutAnnaffiatureInput, UtenteUncheckedCreateWithoutAnnaffiatureInput>
    where?: UtenteWhereInput
  }

  export type UtenteUpdateToOneWithWhereWithoutAnnaffiatureInput = {
    where?: UtenteWhereInput
    data: XOR<UtenteUpdateWithoutAnnaffiatureInput, UtenteUncheckedUpdateWithoutAnnaffiatureInput>
  }

  export type UtenteUpdateWithoutAnnaffiatureInput = {
    nome?: StringFieldUpdateOperationsInput | string
    cognome?: StringFieldUpdateOperationsInput | string
    credenziali?: CredenzialiUpdateOneWithoutUtenteNestedInput
    piantagioni?: PiantagioneUpdateManyWithoutUtenteNestedInput
    notifiche?: NotificheUpdateManyWithoutUtenteNestedInput
  }

  export type UtenteUncheckedUpdateWithoutAnnaffiatureInput = {
    id_utente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    cognome?: StringFieldUpdateOperationsInput | string
    credenziali?: CredenzialiUncheckedUpdateOneWithoutUtenteNestedInput
    piantagioni?: PiantagioneUncheckedUpdateManyWithoutUtenteNestedInput
    notifiche?: NotificheUncheckedUpdateManyWithoutUtenteNestedInput
  }

  export type PiantagioneUpsertWithoutAnnaffiatureInput = {
    update: XOR<PiantagioneUpdateWithoutAnnaffiatureInput, PiantagioneUncheckedUpdateWithoutAnnaffiatureInput>
    create: XOR<PiantagioneCreateWithoutAnnaffiatureInput, PiantagioneUncheckedCreateWithoutAnnaffiatureInput>
    where?: PiantagioneWhereInput
  }

  export type PiantagioneUpdateToOneWithWhereWithoutAnnaffiatureInput = {
    where?: PiantagioneWhereInput
    data: XOR<PiantagioneUpdateWithoutAnnaffiatureInput, PiantagioneUncheckedUpdateWithoutAnnaffiatureInput>
  }

  export type PiantagioneUpdateWithoutAnnaffiatureInput = {
    nome?: StringFieldUpdateOperationsInput | string
    n_slot?: IntFieldUpdateOperationsInput | number
    data_inizio?: DateTimeFieldUpdateOperationsInput | Date | string
    utente?: UtenteUpdateOneRequiredWithoutPiantagioniNestedInput
    pianta?: PiantaUpdateOneRequiredWithoutPiantagioniNestedInput
    notifiche?: NotificheUpdateManyWithoutPiantagioneNestedInput
  }

  export type PiantagioneUncheckedUpdateWithoutAnnaffiatureInput = {
    id_piantagione?: IntFieldUpdateOperationsInput | number
    id_utente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    n_slot?: IntFieldUpdateOperationsInput | number
    data_inizio?: DateTimeFieldUpdateOperationsInput | Date | string
    id_pianta?: IntFieldUpdateOperationsInput | number
    notifiche?: NotificheUncheckedUpdateManyWithoutPiantagioneNestedInput
  }

  export type PiantagioneCreateManyUtenteInput = {
    id_piantagione?: number
    nome: string
    n_slot: number
    data_inizio: Date | string
    id_pianta: number
  }

  export type NotificheCreateManyUtenteInput = {
    id_notifica?: number
    testo: string
    aperta?: boolean
    id_piantagione: number
    nome_piantagione: string
    data_invio: Date | string
    tipo: number
  }

  export type AnnaffiatureCreateManyUtenteInput = {
    id_annaffiatura?: number
    id_piantagione: number
    giorni_rimanenti: number
    data_save: Date | string
  }

  export type PiantagioneUpdateWithoutUtenteInput = {
    nome?: StringFieldUpdateOperationsInput | string
    n_slot?: IntFieldUpdateOperationsInput | number
    data_inizio?: DateTimeFieldUpdateOperationsInput | Date | string
    pianta?: PiantaUpdateOneRequiredWithoutPiantagioniNestedInput
    notifiche?: NotificheUpdateManyWithoutPiantagioneNestedInput
    annaffiature?: AnnaffiatureUpdateManyWithoutPiantagioneNestedInput
  }

  export type PiantagioneUncheckedUpdateWithoutUtenteInput = {
    id_piantagione?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    n_slot?: IntFieldUpdateOperationsInput | number
    data_inizio?: DateTimeFieldUpdateOperationsInput | Date | string
    id_pianta?: IntFieldUpdateOperationsInput | number
    notifiche?: NotificheUncheckedUpdateManyWithoutPiantagioneNestedInput
    annaffiature?: AnnaffiatureUncheckedUpdateManyWithoutPiantagioneNestedInput
  }

  export type PiantagioneUncheckedUpdateManyWithoutUtenteInput = {
    id_piantagione?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    n_slot?: IntFieldUpdateOperationsInput | number
    data_inizio?: DateTimeFieldUpdateOperationsInput | Date | string
    id_pianta?: IntFieldUpdateOperationsInput | number
  }

  export type NotificheUpdateWithoutUtenteInput = {
    testo?: StringFieldUpdateOperationsInput | string
    aperta?: BoolFieldUpdateOperationsInput | boolean
    nome_piantagione?: StringFieldUpdateOperationsInput | string
    data_invio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: IntFieldUpdateOperationsInput | number
    piantagione?: PiantagioneUpdateOneRequiredWithoutNotificheNestedInput
  }

  export type NotificheUncheckedUpdateWithoutUtenteInput = {
    id_notifica?: IntFieldUpdateOperationsInput | number
    testo?: StringFieldUpdateOperationsInput | string
    aperta?: BoolFieldUpdateOperationsInput | boolean
    id_piantagione?: IntFieldUpdateOperationsInput | number
    nome_piantagione?: StringFieldUpdateOperationsInput | string
    data_invio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: IntFieldUpdateOperationsInput | number
  }

  export type NotificheUncheckedUpdateManyWithoutUtenteInput = {
    id_notifica?: IntFieldUpdateOperationsInput | number
    testo?: StringFieldUpdateOperationsInput | string
    aperta?: BoolFieldUpdateOperationsInput | boolean
    id_piantagione?: IntFieldUpdateOperationsInput | number
    nome_piantagione?: StringFieldUpdateOperationsInput | string
    data_invio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: IntFieldUpdateOperationsInput | number
  }

  export type AnnaffiatureUpdateWithoutUtenteInput = {
    giorni_rimanenti?: IntFieldUpdateOperationsInput | number
    data_save?: DateTimeFieldUpdateOperationsInput | Date | string
    piantagione?: PiantagioneUpdateOneRequiredWithoutAnnaffiatureNestedInput
  }

  export type AnnaffiatureUncheckedUpdateWithoutUtenteInput = {
    id_annaffiatura?: IntFieldUpdateOperationsInput | number
    id_piantagione?: IntFieldUpdateOperationsInput | number
    giorni_rimanenti?: IntFieldUpdateOperationsInput | number
    data_save?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnaffiatureUncheckedUpdateManyWithoutUtenteInput = {
    id_annaffiatura?: IntFieldUpdateOperationsInput | number
    id_piantagione?: IntFieldUpdateOperationsInput | number
    giorni_rimanenti?: IntFieldUpdateOperationsInput | number
    data_save?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificheCreateManyPiantagioneInput = {
    id_notifica?: number
    testo: string
    aperta?: boolean
    id_utente: number
    nome_piantagione: string
    data_invio: Date | string
    tipo: number
  }

  export type AnnaffiatureCreateManyPiantagioneInput = {
    id_annaffiatura?: number
    id_utente: number
    giorni_rimanenti: number
    data_save: Date | string
  }

  export type NotificheUpdateWithoutPiantagioneInput = {
    testo?: StringFieldUpdateOperationsInput | string
    aperta?: BoolFieldUpdateOperationsInput | boolean
    nome_piantagione?: StringFieldUpdateOperationsInput | string
    data_invio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: IntFieldUpdateOperationsInput | number
    utente?: UtenteUpdateOneRequiredWithoutNotificheNestedInput
  }

  export type NotificheUncheckedUpdateWithoutPiantagioneInput = {
    id_notifica?: IntFieldUpdateOperationsInput | number
    testo?: StringFieldUpdateOperationsInput | string
    aperta?: BoolFieldUpdateOperationsInput | boolean
    id_utente?: IntFieldUpdateOperationsInput | number
    nome_piantagione?: StringFieldUpdateOperationsInput | string
    data_invio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: IntFieldUpdateOperationsInput | number
  }

  export type NotificheUncheckedUpdateManyWithoutPiantagioneInput = {
    id_notifica?: IntFieldUpdateOperationsInput | number
    testo?: StringFieldUpdateOperationsInput | string
    aperta?: BoolFieldUpdateOperationsInput | boolean
    id_utente?: IntFieldUpdateOperationsInput | number
    nome_piantagione?: StringFieldUpdateOperationsInput | string
    data_invio?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: IntFieldUpdateOperationsInput | number
  }

  export type AnnaffiatureUpdateWithoutPiantagioneInput = {
    giorni_rimanenti?: IntFieldUpdateOperationsInput | number
    data_save?: DateTimeFieldUpdateOperationsInput | Date | string
    utente?: UtenteUpdateOneRequiredWithoutAnnaffiatureNestedInput
  }

  export type AnnaffiatureUncheckedUpdateWithoutPiantagioneInput = {
    id_annaffiatura?: IntFieldUpdateOperationsInput | number
    id_utente?: IntFieldUpdateOperationsInput | number
    giorni_rimanenti?: IntFieldUpdateOperationsInput | number
    data_save?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnaffiatureUncheckedUpdateManyWithoutPiantagioneInput = {
    id_annaffiatura?: IntFieldUpdateOperationsInput | number
    id_utente?: IntFieldUpdateOperationsInput | number
    giorni_rimanenti?: IntFieldUpdateOperationsInput | number
    data_save?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PiantagioneCreateManyPiantaInput = {
    id_piantagione?: number
    id_utente: number
    nome: string
    n_slot: number
    data_inizio: Date | string
  }

  export type PiantagioneUpdateWithoutPiantaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    n_slot?: IntFieldUpdateOperationsInput | number
    data_inizio?: DateTimeFieldUpdateOperationsInput | Date | string
    utente?: UtenteUpdateOneRequiredWithoutPiantagioniNestedInput
    notifiche?: NotificheUpdateManyWithoutPiantagioneNestedInput
    annaffiature?: AnnaffiatureUpdateManyWithoutPiantagioneNestedInput
  }

  export type PiantagioneUncheckedUpdateWithoutPiantaInput = {
    id_piantagione?: IntFieldUpdateOperationsInput | number
    id_utente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    n_slot?: IntFieldUpdateOperationsInput | number
    data_inizio?: DateTimeFieldUpdateOperationsInput | Date | string
    notifiche?: NotificheUncheckedUpdateManyWithoutPiantagioneNestedInput
    annaffiature?: AnnaffiatureUncheckedUpdateManyWithoutPiantagioneNestedInput
  }

  export type PiantagioneUncheckedUpdateManyWithoutPiantaInput = {
    id_piantagione?: IntFieldUpdateOperationsInput | number
    id_utente?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    n_slot?: IntFieldUpdateOperationsInput | number
    data_inizio?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UtenteCountOutputTypeDefaultArgs instead
     */
    export type UtenteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UtenteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PiantagioneCountOutputTypeDefaultArgs instead
     */
    export type PiantagioneCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PiantagioneCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PiantaCountOutputTypeDefaultArgs instead
     */
    export type PiantaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PiantaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UtenteDefaultArgs instead
     */
    export type UtenteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UtenteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CredenzialiDefaultArgs instead
     */
    export type CredenzialiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CredenzialiDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PiantagioneDefaultArgs instead
     */
    export type PiantagioneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PiantagioneDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PiantaDefaultArgs instead
     */
    export type PiantaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PiantaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificheDefaultArgs instead
     */
    export type NotificheArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificheDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnnaffiatureDefaultArgs instead
     */
    export type AnnaffiatureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnnaffiatureDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}